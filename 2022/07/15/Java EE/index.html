<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/my-favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/my-favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"teksab.cn","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Java 概述  JVM、JRE和JDK的关系  JVM  Java Virtual Machine是Java虚拟机，Java程序需要运行在虚拟机上，不同的平台有自己的虚拟机，因此Java语言可以实现跨平台。  JRE  Java Runtime Environment包括Java虚拟机和Java程序所需的核心类库等。核心类库主要是java.lang包：包含了运行Java程序必不可少的系统类，如">
<meta property="og:type" content="article">
<meta property="og:title" content="Java核心技术">
<meta property="og:url" content="http://teksab.cn/2022/07/15/Java%20EE/index.html">
<meta property="og:site_name" content="Double&#39;s Blog">
<meta property="og:description" content="Java 概述  JVM、JRE和JDK的关系  JVM  Java Virtual Machine是Java虚拟机，Java程序需要运行在虚拟机上，不同的平台有自己的虚拟机，因此Java语言可以实现跨平台。  JRE  Java Runtime Environment包括Java虚拟机和Java程序所需的核心类库等。核心类库主要是java.lang包：包含了运行Java程序必不可少的系统类，如">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://teksab-blog-img.oss-cn-guangzhou.aliyuncs.com/img/Java%20EE/202209191100897.png">
<meta property="og:image" content="https://teksab-blog-img.oss-cn-guangzhou.aliyuncs.com/img/Java%20EE/202209191102533.png">
<meta property="og:image" content="https://teksab-blog-img.oss-cn-guangzhou.aliyuncs.com/img/Java%20EE/202209191102317.png">
<meta property="og:image" content="d:%5CStudy%5CJava%E7%9F%A5%E8%AF%86%5Cmarkdown%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E9%9B%86%E5%90%88%E7%B1%BB.png">
<meta property="article:published_time" content="2022-07-15T08:46:07.000Z">
<meta property="article:modified_time" content="2022-09-20T02:45:00.475Z">
<meta property="article:author" content="Double">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://teksab-blog-img.oss-cn-guangzhou.aliyuncs.com/img/Java%20EE/202209191100897.png">

<link rel="canonical" href="http://teksab.cn/2022/07/15/Java%20EE/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java核心技术 | Double's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

  <!-- 页面点击小红心 -->
  <script type="text/javascript" src="/js/clicklove.js"></script>
<style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Double's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">努力学习，好好生活</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">2</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">3</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">2</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://teksab.cn/2022/07/15/Java%20EE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/author.jpg">
      <meta itemprop="name" content="Double">
      <meta itemprop="description" content="KEEP CALM & Carry On">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Double's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java核心技术
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-15 16:46:07" itemprop="dateCreated datePublished" datetime="2022-07-15T16:46:07+08:00">2022-07-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>35k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>32 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="java-概述"><a class="markdownIt-Anchor" href="#java-概述"></a> Java 概述</h1>
<h2 id="jvm-jre和jdk的关系"><a class="markdownIt-Anchor" href="#jvm-jre和jdk的关系"></a> JVM、JRE和JDK的关系</h2>
<ul>
<li><strong>JVM</strong></li>
</ul>
<p>Java Virtual Machine是Java虚拟机，Java程序需要运行在虚拟机上，不同的平台有自己的虚拟机，因此Java语言可以实现跨平台。</p>
<ul>
<li><strong>JRE</strong></li>
</ul>
<p>Java Runtime Environment包括Java虚拟机和Java程序所需的核心类库等。核心类库主要是java.lang包：包含了运行Java程序必不可少的系统类，如基本数据类型、基本数学函数、字符串处理、线程、异常处理类等，系统缺省加载这个包</p>
<p>如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。</p>
<ul>
<li><strong>JDK</strong></li>
</ul>
<p>Java Development Kit是提供给Java开发人员使用的，其中包含了Java的开发工具，也包括了JRE。所以安装了JDK，就无需再单独安装JRE了。其中的开发工具：编译工具(javac.exe)，打包工具(jar.exe)等</p>
<p><em><span id="more"></span></em></p>
<ul>
<li><strong>JVM&amp;JRE&amp;JDK关系图</strong></li>
</ul>
<p><img src="https://teksab-blog-img.oss-cn-guangzhou.aliyuncs.com/img/Java%20EE/202209191100897.png" alt="JVM、JRE和JDK"></p>
<h1 id="java基础语法"><a class="markdownIt-Anchor" href="#java基础语法"></a> Java基础语法</h1>
<h2 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h2>
<p>Java的基本数据类型中 <strong>并没有</strong> <em><strong>String</strong></em> 类型</p>
<h3 id="整数类型"><a class="markdownIt-Anchor" href="#整数类型"></a> 整数类型</h3>
<table>
<thead>
<tr>
<th style="text-align:center">数据类型</th>
<th style="text-align:center">字节</th>
<th style="text-align:center">长度</th>
<th style="text-align:center">取值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Byte</td>
<td style="text-align:center">1</td>
<td style="text-align:center">8位</td>
<td style="text-align:center">-2<sup>7</sup>~2<sup>7</sup>-1</td>
</tr>
<tr>
<td style="text-align:center">short</td>
<td style="text-align:center">2</td>
<td style="text-align:center">16位</td>
<td style="text-align:center">-2<sup>15</sup>~2<sup>15</sup>-1</td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">4</td>
<td style="text-align:center">32位</td>
<td style="text-align:center">-2<sup>31</sup>~2<sup>31</sup>-1</td>
</tr>
<tr>
<td style="text-align:center">long</td>
<td style="text-align:center">8</td>
<td style="text-align:center">64位</td>
<td style="text-align:center">-2<sup>63</sup>~2<sup>63</sup>-1</td>
</tr>
</tbody>
</table>
<p>long在赋值时与int区分开需要在正数后面加上 <strong>L</strong> 或 l，十六进制数值有一个前缀 <strong>0x</strong></p>
<h3 id="浮点类型"><a class="markdownIt-Anchor" href="#浮点类型"></a> 浮点类型</h3>
<table>
<thead>
<tr>
<th style="text-align:center">数据类型</th>
<th style="text-align:center">字节</th>
<th style="text-align:center">长度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">float</td>
<td style="text-align:center">4</td>
<td style="text-align:center">32位</td>
</tr>
<tr>
<td style="text-align:center">double</td>
<td style="text-align:center">8</td>
<td style="text-align:center">64位</td>
</tr>
</tbody>
</table>
<h3 id="字符类型"><a class="markdownIt-Anchor" href="#字符类型"></a> 字符类型</h3>
<p>char类型的字面量值要用单引号括起来，如 <code>'A'</code>,与<code>"A"</code>不同的是，后者表示字符串。</p>
<ol>
<li>char型</li>
<li>转义字符       以反斜杠“ \ ”开头，后跟一个或多个字符</li>
</ol>
<h3 id="boolean-类型"><a class="markdownIt-Anchor" href="#boolean-类型"></a> Boolean 类型</h3>
<p>boolean类型有两个值：false和true，用来判断逻辑条件。<em><strong>整型值和布尔值之间不能进行相互转换</strong></em>。</p>
<h2 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h2>
<h3 id="变量-2"><a class="markdownIt-Anchor" href="#变量-2"></a> 变量</h3>
<p>变量名必须是一个以字母开头的由字母或数字构成的序列。变量名中所有的字母都是有意义的，且大小写敏感。另外不能将变量名命名为Java保留字；声明一个变量后，<strong>必须用赋值语句对变量进行显式初始化。</strong></p>
<h3 id="常量"><a class="markdownIt-Anchor" href="#常量"></a> 常量</h3>
<p>常量使用 <strong>final</strong>  关键字进行限定，常量名使用全大写。</p>
<p>在Java中，如果希望某个常量可以在一个类中的多个方法中使用，通常将这些常量称为类常量，使用关键字</p>
<p><strong>static final</strong> 设置一个类常量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Constant</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">CM_PER_INCH</span> <span class="operator">=</span> <span class="number">2.54</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	{</span><br><span class="line">    	...</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 类常量的定义位于main方法的外部。                                                           </span></span><br></pre></td></tr></table></figure>
<h2 id="运算符"><a class="markdownIt-Anchor" href="#运算符"></a> 运算符</h2>
<h3 id="位运算符"><a class="markdownIt-Anchor" href="#位运算符"></a> 位运算符</h3>
<ol>
<li>位逻辑运算</li>
</ol>
<p>可以使用屏蔽技术获得整数中的各个位，位运算符包括：&amp;(与) ，|（或），^（异或）, ~（取反）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">fourthBitFromRight</span> <span class="operator">=</span> (n &amp; <span class="number">0b1000</span>)/ <span class="number">0b1000</span></span><br><span class="line">如果整型变量n第四位为<span class="number">1</span>，fourthBitFromRight为<span class="number">1</span>，否则为<span class="number">0</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>位移运算符</li>
</ol>
<p>&gt;&gt; (右移) ，&lt;&lt; （左移），&gt;&gt;&gt;（无符号右移）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">fourthBitFromRight</span> <span class="operator">=</span> (n &amp; (<span class="number">1</span>&lt;&lt;<span class="number">3</span>)) &gt;&gt; <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>将任意数字以二进制的方式进行位数移动运算</p>
<h3 id="三元运算符"><a class="markdownIt-Anchor" href="#三元运算符"></a> 三元运算符</h3>
<p>三元运算符的使用格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">条件表达式 ？ 值<span class="number">1</span> 值<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>若条件表达式的值位true，则整个表达式取值1，否则取值2，等价于if……else语句</p>
<h2 id="字符串"><a class="markdownIt-Anchor" href="#字符串"></a> 字符串</h2>
<p>Java中，单引号中的内容表示字符，而双引号的内容则表示字符串。</p>
<h3 id="string-类"><a class="markdownIt-Anchor" href="#string-类"></a> String 类</h3>
<ol>
<li>声明字符串</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String a;</span><br></pre></td></tr></table></figure>
<p>在不给字符串变量赋值的情况下，其默认值为  <strong>null</strong> ，如果此时调用String的方法，则会发生空指针异常。</p>
<ol start="2">
<li>创建字符串</li>
</ol>
<blockquote>
<ol>
<li>引用字符串常量</li>
</ol>
<p>直接将字符串常量赋值给String类型变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">"Java Programming"</span>;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>利用<strong>构造方法</strong>实例化</li>
</ol>
<p>使用new关键字创建String对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"我爱火锅"</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(a);</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>利用字符数组<strong>实例化</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>[] charArray = {<span class="string">'t'</span>,<span class="string">'i'</span>,<span class="string">'m'</span>,<span class="string">'e'</span>};</span><br><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(charArray);</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>提取字符数组的一部分创建字符串对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>[] charArray = {<span class="string">'t'</span>,<span class="string">'i'</span>,<span class="string">'m'</span>,<span class="string">'e'</span>};</span><br><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(charArray,<span class="number">2</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="字符串的连接"><a class="markdownIt-Anchor" href="#字符串的连接"></a> 字符串的连接</h3>
<ol>
<li>
<p>使用 <strong>“+”</strong> 运算符或 <strong>“+=”</strong> 可以连接多个字符串并产生一个String对象。</p>
</li>
<li>
<p>String自带的concat() 方法可以实现将指定字符串连接到此字符串结尾的功能</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oldstr.concat(str);</span><br></pre></td></tr></table></figure>
<ul>
<li>oldstr:原字符串</li>
<li>str:原字符串末尾拼接的字符串</li>
</ul>
<h3 id="不可变字符串"><a class="markdownIt-Anchor" href="#不可变字符串"></a> 不可变字符串</h3>
<p>Java将String类对象称为不可变字符串，String类没有提供用于修改字符串的方法，可以引用另一个字符串达到修改的效果。</p>
<h3 id="空串与null串"><a class="markdownIt-Anchor" href="#空串与null串"></a> 空串与NULL串</h3>
<p>空串 “” 是长度为0的字符串，空串是一个有自己的长度（0）和内容（空）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检查空串</span></span><br><span class="line"><span class="keyword">if</span>(str.lenght() == <span class="number">0</span>)   或  <span class="keyword">if</span>(str.equals(<span class="string">""</span>))</span><br><span class="line"><span class="comment">//检查NULL串</span></span><br><span class="line"><span class="keyword">if</span>(str==<span class="literal">null</span>)</span><br></pre></td></tr></table></figure>
<h3 id="提取字符串信息"><a class="markdownIt-Anchor" href="#提取字符串信息"></a> 提取字符串信息</h3>
<ol>
<li>获取字符串的长度</li>
</ol>
<p><strong>length()</strong> 方法返回字符数量，获取字符串长度，也就是char的数量</p>
<blockquote>
<p>String的length()方法是类的成员方法，有括号；数组的length属性是数组的一个属性，没有括号。</p>
</blockquote>
<ol start="2">
<li>获取指定位置的字符</li>
</ol>
<p><strong>charAt( int  index)</strong> 方法用来获取指定索引的字符</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.charAt(<span class="type">int</span> index);</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>获取子字符串索引的位置</li>
</ol>
<p><strong>indexOf()</strong> 方法返回子字符串在字符串中首次出现的索引位置，如果没有检索到要查找的字符或字符串，则返回 <mark><strong>-1</strong></mark></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str.indexOf(String substr);</span><br><span class="line">str.indexOf(String substr,<span class="type">int</span> fromIndex);</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>判断字符串首尾内容</li>
</ol>
<ul>
<li><strong>startsWith(String  prefix)</strong>  方法用于判断字符串是否以指定的前缀开始</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.startsWith(prefix);  <span class="comment">//返回boolean类型</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>endsWith(String  suffix)</strong> 方法判断字符串是否以指定的后缀结束</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.endsWith(suffix);	<span class="comment">//返回boolean类型</span></span><br></pre></td></tr></table></figure>
<ol start="5">
<li>获取字符数组</li>
</ol>
<p><strong>toCharArray()</strong> 方法可以将字符串转换为一个字符数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>[] ch = str.toCharArray();</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>判断子字符串是否存在</li>
</ol>
<p><strong>contains()</strong> 方法可以判断字符串中是否包含指定的内容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.contains(String str);	<span class="comment">//返回boolean类型</span></span><br></pre></td></tr></table></figure>
<h3 id="字符串的操作"><a class="markdownIt-Anchor" href="#字符串的操作"></a> 字符串的操作</h3>
<ol>
<li>截取字符串</li>
</ol>
<p><strong>substring()</strong> 方法返回一个<strong>新字符串</strong>，该字符串从指定的beginIndex处的字符开始，直到<strong>endIndex-1</strong>处的字符结束</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str.substring(<span class="type">int</span> beginIndex);</span><br><span class="line">str.sunstring(<span class="type">int</span> beginIndex, <span class="type">int</span> endIndex);		<span class="comment">//endIndex处内容不包括</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>字符串替换</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">replace(CharSequence oldstr,CharSequence newstr);</span><br><span class="line"><span class="comment">//用String或StringBuilder对象作为CharSequence参数</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>replace()</strong> 方法返回的是一个新字符串，如果字符串str中没有找到需要被替换的子字符串序列oldstr，则将原字符串返回</li>
</ul>
<ol start="3">
<li>字符串分割</li>
</ol>
<p><strong>split()</strong> 方法可根据给定的分隔符对字符串进行拆分，支持***正则表达式*** ，最后返回一个字符串数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.split(regex);	<span class="comment">//分隔符表达式</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>大小写转换</li>
</ol>
<p><strong>toLowerCase()</strong> 方法可以将字符串中所有的字符转换为小写。如果字符串中没有应该被转换的字符，则将原字符串返回，否则将返回一个新字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.toLowerCase();</span><br></pre></td></tr></table></figure>
<p><strong>toUpperCase()</strong> 方法可以将字符串中所有的字符转换为大写。如果字符串中没有应该被转换的字符，则将原字符串返回，否则将返回一个新字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.UpperCase();</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>去除空白内容</li>
</ol>
<p><strong>trim()</strong> 方法可以将字符串<strong>首尾</strong>处的空白内容都删除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.trim();</span><br></pre></td></tr></table></figure>
<h3 id="构建字符串"><a class="markdownIt-Anchor" href="#构建字符串"></a> 构建字符串</h3>
<p>StringBuffer类是<strong>线程安全</strong>的可变字符序列，一个类似与String类的<strong>字符串缓冲区</strong>。String类创建的字符串对象是不可修改的，StringBuffer类创建的字符串序列是可以修改的。String只能赋值一次，每一次内容发生改变都会生成一个新的对象，既耗时又浪费空间，所以说String本身是不可改变的。而StringBuffer不同，每次都是操作自身对象，而不是生成新的对象。</p>
<blockquote>
<p>StringBuilder类的前身是StringBuffer，<strong>StringBuffer效率有点低</strong>，但允许采用多线程的方式执行添加或删除字符的操作。如果所有字符串在一个单线程中，应该用StringBuilder替代它。这两个类的API是相同的。</p>
</blockquote>
<ol>
<li>创建StringBuffer类</li>
</ol>
<p>创建一个新的StringBuffer对象必须使用<strong>new</strong>，不能像String对象直接引用字符串常量</p>
<ol start="2">
<li>append()方法</li>
</ol>
<p><strong>append()</strong> 方法可以将参数转换为字符串，然后追加到此序列中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sbf.append(obj);  <span class="comment">//obj可以是一个单字符或字符串</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>setCharAt(int  index, cahr  ch)方法</li>
</ol>
<p><strong>setCharAt(int  index, cahr  ch)</strong> 方法将给定索引处的字符修改为ch</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sbf.setCharAt(<span class="type">int</span> index, <span class="type">char</span> ch);</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>inset(int offset, String  str )方法</li>
</ol>
<p><strong>inset(int offset, String  str )</strong> 方法将str插入到指定的索引值offset位置上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sbf.insert(<span class="type">int</span> offset, <span class="type">char</span> str);</span><br><span class="line">sbf.insert(<span class="type">int</span> offset, String str);</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>delete(int  start, int   end) 方法</li>
</ol>
<p><strong>delete(int  start, int   end)</strong>  方法可移除此序列中子字符串中的字符。该子字符串从指定的索引start处开始，一直到索引处<strong>end-1</strong> 处结束，如果end-1超出最大索引范围，则一直到序列尾部</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sbf.delete(<span class="type">int</span> start,<span class="type">int</span> end);   <span class="comment">//end不包含</span></span><br></pre></td></tr></table></figure>
<h2 id="输入输出"><a class="markdownIt-Anchor" href="#输入输出"></a> 输入输出</h2>
<h3 id="读取输入"><a class="markdownIt-Anchor" href="#读取输入"></a> 读取输入</h3>
<p>要想通过控制台进行输入，首先需要构造一个Scanner对象，并与“标准输入流” <a target="_blank" rel="noopener" href="http://System.in">System.in</a> 关联</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in)</span><br></pre></td></tr></table></figure>
<ul>
<li>API  java.util.Scanner 5.0</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">nextLine</span><span class="params">()</span>;       <span class="comment">//读取输入的下一行内容</span></span><br><span class="line">String <span class="title function_">next</span><span class="params">()</span>;		     <span class="comment">//读取输入的下一个单词（以空格为分隔符）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">nextInt</span><span class="params">()</span>;			 <span class="comment">//读取下一个整数</span></span><br><span class="line">Double <span class="title function_">nextDouble</span><span class="params">()</span>;	 <span class="comment">//读取下一个浮点数</span></span><br><span class="line">Boolean <span class="title function_">hasNext</span><span class="params">()</span>;		 <span class="comment">//检测输入中是否还有其他单词</span></span><br><span class="line">Boolean <span class="title function_">hasNextInt</span><span class="params">()</span>;	 <span class="comment">//检测输入中是否还有表示整数的下一个字符</span></span><br><span class="line">Boolean <span class="title function_">hasNextDouble</span><span class="params">()</span>; <span class="comment">//检测输入中是否还有表示浮点数的下一个字符</span></span><br></pre></td></tr></table></figure>
<h3 id="格式化输出"><a class="markdownIt-Anchor" href="#格式化输出"></a> 格式化输出</h3>
<p>Java SE 5.0 沿用了C语言中的printf方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.printf(<span class="string">"%8.2f"</span>,<span class="number">10000.0</span>/<span class="number">3.0</span>)   <span class="comment">//打印一个空格加七个字符  “ 3333.33”</span></span><br><span class="line">System.out.printf(<span class="string">"%,.2f"</span>,<span class="number">10000.0</span>/<span class="number">3.0</span>)   <span class="comment">//逗号标志增加分组的分隔符，打印3,333.33</span></span><br></pre></td></tr></table></figure>
<ul>
<li>用于printf的标志</li>
</ul>
<table>
<thead>
<tr>
<th>标志</th>
<th>目的</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>打印正数和负数的符号</td>
<td>+3333.33</td>
</tr>
<tr>
<td>空格</td>
<td>在正数前面加空格</td>
<td>| 3333.33|</td>
</tr>
<tr>
<td>0</td>
<td>数字前面补0</td>
<td>003333.33</td>
</tr>
<tr>
<td>-</td>
<td>左对齐</td>
<td>|3333.33 |</td>
</tr>
<tr>
<td>（</td>
<td>将负数括在括号里</td>
<td>(3333.33)</td>
</tr>
<tr>
<td>，</td>
<td>添加分组分隔符</td>
<td>3,333.</td>
</tr>
</tbody>
</table>
<h3 id="文件输入与输出"><a class="markdownIt-Anchor" href="#文件输入与输出"></a> 文件输入与输出</h3>
<p>要想对文件进行读取，就需要一个用File对象构造一个Scanner对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scannner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(Paths.get(<span class="string">"myfile.txt"</span>),<span class="string">"UTF-8"</span>);</span><br></pre></td></tr></table></figure>
<p>要想写入文件，就需要构造一个PrintWrite对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PrintWrite</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWrite</span>(<span class="string">"myfile.txt"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="控制流程"><a class="markdownIt-Anchor" href="#控制流程"></a> 控制流程</h2>
<h3 id="条件语句"><a class="markdownIt-Anchor" href="#条件语句"></a> 条件语句</h3>
<ol>
<li>常见的条件语句格式</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(condition)</span><br><span class="line">{</span><br><span class="line">	...</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span>			<span class="comment">//else部分可选，且else子句与最邻近的if构成一组</span></span><br><span class="line">{</span><br><span class="line">	...</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>switch-case多分支语句后表达式的数据类型包括 <strong>6</strong> 种：<strong>int</strong>， <strong>short</strong>，<strong>char</strong>，<strong>byte</strong>，<strong>String</strong> 和 <strong>enum</strong>（枚举类型），特别注意没有浮点类型</li>
</ol>
<h3 id="循环语句"><a class="markdownIt-Anchor" href="#循环语句"></a> 循环语句</h3>
<p>do/while循环语句可以实现循环体至少执行一次</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">{</span><br><span class="line">	...</span><br><span class="line">}<span class="keyword">while</span>(condition)</span><br></pre></td></tr></table></figure>
<h2 id="大数值"><a class="markdownIt-Anchor" href="#大数值"></a> 大数值</h2>
<p>如果基本的整数和浮点数精度不能够满足需求，可以使用java.math包中的两个类：<strong>BIgInteger</strong> 和 <strong>BigDecimal</strong></p>
<p>BIgInteger类实现了任意精度的整数运算，BIgDecimal实现了任意精度的浮点数运算。</p>
<p>使用静态的valueOf方法可以将普通数值转换为大数值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">a</span> <span class="operator">=</span> BigInteger.valueOf(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>不能使用算术运算符（如：+和*）处理大数值，需要使用大数值类中的add和multiply方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">c</span> <span class="operator">=</span> a.add(b);                                   <span class="comment">//c=a+b</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">d</span> <span class="operator">=</span> c.multiply(b.add(BigInteger.valueOf(<span class="number">2</span>)));   <span class="comment">//d=c*(b+2)</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>API java.math.BigInteger  1.1</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BigInteger <span class="title function_">add</span><span class="params">(BigInteger other)</span>; </span><br><span class="line">BigInteger <span class="title function_">subtract</span><span class="params">(BigInteger other)</span>; </span><br><span class="line">BigInteger <span class="title function_">multiply</span><span class="params">(BigInteger other)</span>; </span><br><span class="line">BigInteger <span class="title function_">divide</span><span class="params">(BigInteger other)</span>;</span><br><span class="line">BigInteger <span class="title function_">mod</span><span class="params">(BigInteger other)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(BigInteger other)</span>;            <span class="comment">//相等返回0，小于返回负数，否则返回正数</span></span><br></pre></td></tr></table></figure>
<h2 id="数组"><a class="markdownIt-Anchor" href="#数组"></a> 数组</h2>
<p>Java中将数组看成一个 <strong>对象</strong>，虽然基本数据类型不是对象，但是由基本数据类型组成的数组则是对象。</p>
<h3 id="一维数组"><a class="markdownIt-Anchor" href="#一维数组"></a> 一维数组</h3>
<ol>
<li>创建一维数组</li>
</ol>
<p>​	声明一维数组 的两种方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">数组元素类型  数组名字[];</span><br><span class="line">数组元素类型[] 数组名字;</span><br><span class="line"></span><br><span class="line">如：</span><br><span class="line">  <span class="type">int</span> a[];</span><br><span class="line">  <span class="type">int</span>[] a;		<span class="comment">//提倡这种风格，因为它将类型与变量分开了</span></span><br></pre></td></tr></table></figure>
<p>分配内存空间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">数组名字 = <span class="keyword">new</span> 数组元素类型[数组元素的个数];</span><br><span class="line"></span><br><span class="line">如：</span><br><span class="line">  a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>
<p>将数组的声明和分配内存空间一起执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">数组元素类型 数组名 = <span class="keyword">new</span> 数组元素类型[数组元素个数];</span><br><span class="line"> </span><br><span class="line">如：</span><br><span class="line">  <span class="type">int</span> a[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">12</span>]; </span><br></pre></td></tr></table></figure>
<p>创建一个数字数组时，<strong>所有元素都初始化为 0 ；boolean数组的元素会被初始化为 false ，对象数组的元素会被初始化为一个特殊值 null</strong></p>
<ol start="2">
<li>获取数组长度</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.length</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>数组初始化</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] smallPrimes = {<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>};   <span class="comment">//方式一：使用这种语句时，不需要调用new</span></span><br><span class="line">smallPrimes = <span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>};<span class="comment">//方式二：使用匿名数组</span></span><br></pre></td></tr></table></figure>
<h3 id="for-each语句"><a class="markdownIt-Anchor" href="#for-each语句"></a> for each语句</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(variable : colletion){	<span class="comment">//colletion表达式必须是一个数组或是一个实现了Iterable接口的类对象</span></span><br><span class="line">	...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//example：</span></span><br><span class="line"><span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">15</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> element:a)</span><br><span class="line">    System.out.println(element);	<span class="comment">//打印数组a的每一个元素</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>for each循环语句中的循环变量将会遍历数组中的每一个元素，不需要使用下标值。</li>
<li>要打印数组中的所有值，可以调用 <strong>System.out.println(Arrays.toString(b))</strong></li>
</ol>
</blockquote>
<h3 id="命令行数组"><a class="markdownIt-Anchor" href="#命令行数组"></a> 命令行数组</h3>
<p>在每一个Java程序的主方法main()中，都有一个String args[]的字符串数组；这个参数表面main方法将接收一个</p>
<p>字符串数组，也就是命令行参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="keyword">if</span>(args[<span class="number">0</span>].equals(<span class="string">"-h"</span>))</span><br><span class="line">            System.out.print(<span class="string">"Hello,"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(args[<span class="number">0</span>].equals(<span class="string">"-g"</span>))</span><br><span class="line">            System.out.print(<span class="string">"Goodbye"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;args.length;i++)</span><br><span class="line">            System.out.print(<span class="string">" "</span>+args[i]);</span><br><span class="line">        System.out.println(<span class="string">"!"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//使用命令行形式运行程序：java demo -g cruel world</span></span><br><span class="line"><span class="comment">//程序将输出：Goodbye,cruel world!</span></span><br></pre></td></tr></table></figure>
<h3 id="数组拷贝"><a class="markdownIt-Anchor" href="#数组拷贝"></a> 数组拷贝</h3>
<p>允许将一个数组变量拷贝给另一个数组变量，这时这两个变量将引用同一个数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] nums2 = nums1;</span><br></pre></td></tr></table></figure>
<p>如果希望一个数组的所有值拷贝到另一个数组中，需要使用 <code>Arrays</code> 类中的 <code>copyOf</code> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] nums2 = Arrays.copyOf(nums1,nums1.length);</span><br></pre></td></tr></table></figure>
<h3 id="多维数组"><a class="markdownIt-Anchor" href="#多维数组"></a> 多维数组</h3>
<p>创建二维数组可以只声明行的长度，而不声明列的长度；如果只声明列的长度而不声明行的长度的话，就属于错误写法。</p>
<p>Java支持不规则的数组，例如二维数组中，不同行的元素个数可以不同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[][] = <span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">3</span>][];</span><br><span class="line">a[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">5</span>];</span><br><span class="line">a[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">4</span>];</span><br><span class="line">a[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">int</span> [<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">其中：</span><br><span class="line">a.length 用以表示二维数组的行数</span><br><span class="line">a[i].length 用以表示二维数组第i行的列数</span><br></pre></td></tr></table></figure>
<h3 id="数组的基本操作"><a class="markdownIt-Anchor" href="#数组的基本操作"></a> 数组的基本操作</h3>
<ol>
<li>遍历数组</li>
</ol>
<p>方式一：过 <strong>for</strong> 循环和数组的 <strong>length</strong> 属性来遍历数组。</p>
<p>方式二：使用 <strong>foreach</strong> 循环语句遍历</p>
<ol start="2">
<li>填充和批量替换数组元素</li>
</ol>
<p>通过<strong>Array</strong>类的静态方法 <strong>fill()</strong> 方法对数组中的元素进行分配，<strong>fill()</strong> 方法可将指定的 int 值分配给 int 型数组的每个元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.fill(<span class="type">int</span>[] a , <span class="type">int</span> value);</span><br></pre></td></tr></table></figure>
<ul>
<li>value：要存储数组中所有元素的值</li>
</ul>
<ol start="3">
<li>数组拷贝</li>
</ol>
<p>在Java中，允许将一个数组变量拷贝给另一个数组变量；此时这两个数组变量将引用同一个数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] luckNumbers = smallPrimes;	</span><br></pre></td></tr></table></figure>
<p>要想将一个数组的所有值拷贝到一个新的数组中去，需要使用Arrays类中的copyOf() 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] copiedluckNumbers=Arrays.copyOf(luckNumbers,luckNumbers.length);</span><br></pre></td></tr></table></figure>
<p>第二个参数是新数组的长度，这个方法通常用来增加数组的大小。如果长度大于原始数组长度，多余部分会被赋值为默认值；如果长度小于原始数组长度，则只会拷贝前面的数据元素。</p>
<ol start="4">
<li>数组排序</li>
</ol>
<p>要想对数组进行排序，可以使用 <strong>Arrays</strong> 类中的 <strong>sort</strong> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100</span>];</span><br><span class="line">...</span><br><span class="line">Arrays.sort(a);</span><br></pre></td></tr></table></figure>
<p>这个方法采用了优化的快速排序算法。</p>
<h1 id="面向对象"><a class="markdownIt-Anchor" href="#面向对象"></a> 面向对象</h1>
<p>面向对象程序设计（ <strong>OOP</strong> ）的特点：</p>
<ol>
<li>封装性</li>
<li>继承性</li>
<li>多态性</li>
</ol>
<h2 id="类与对象"><a class="markdownIt-Anchor" href="#类与对象"></a> 类与对象</h2>
<ol>
<li>类是构造对象的模板。在类之间，最常见的关系有：</li>
</ol>
<ul>
<li>依赖（“users-a”）</li>
<li>聚合（“has-a”）</li>
<li>继承（“is-a”）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class 类名称{</span><br><span class="line">	<span class="comment">// 类的成员变量</span></span><br><span class="line">	<span class="comment">// 类的成员方法</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>对象与对象变量</li>
</ol>
<p>使用构造器构造一个对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Date bitrhday=<span class="keyword">new</span> <span class="title class_">Date</span>();	<span class="comment">//构造一个对象birthday，并对其进行初始化</span></span><br><span class="line">Date deadline;				<span class="comment">//deadline是一个对象变量</span></span><br><span class="line">deadline=bithday;			<span class="comment">//要想使用deadline，必须对其进行初始化，此时deadline并没有包含一个对象，而仅仅是引用一个对象</span></span><br></pre></td></tr></table></figure>
<h3 id="成员变量"><a class="markdownIt-Anchor" href="#成员变量"></a> 成员变量</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型 变量名称 [ = 值 ];</span><br></pre></td></tr></table></figure>
<p>不设置初始值时，成员变量为 <strong>默认值</strong></p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>byte、short、int、ong</code></td>
<td>0</td>
</tr>
<tr>
<td><code>float、double</code></td>
<td>0.0</td>
</tr>
<tr>
<td><code>char</code></td>
<td>’ ’</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><strong>false</strong></td>
</tr>
<tr>
<td>引用类型，例如 <code>String</code></td>
<td>null</td>
</tr>
</tbody>
</table>
<h3 id="成员方法"><a class="markdownIt-Anchor" href="#成员方法"></a> 成员方法</h3>
<ol>
<li>成员方法的定义</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[权限修饰符] [返回值类型] 方法名 ( [参数类型 参数名] ) [<span class="keyword">throws</span> 异常类型]{</span><br><span class="line">	……<span class="comment">//方法体</span></span><br><span class="line">	<span class="keyword">return</span> 返回值;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>方法参数</li>
</ol>
<p>很多程序设计语言提供了两种参数传递方式：<code>值调用和引用调用</code>。<strong>Java程序设计语言总是采用<code>按值调用</code></strong>。方法得到的是所有参数值的一个拷贝，特别的是方法不能修改传递给它的任何参数变量的内容。</p>
<p>方法参数共有两种类型：</p>
<ul>
<li>基本数据类型（数字，布尔值）</li>
<li>对象引用</li>
</ul>
<p>方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。</p>
<blockquote>
<p>很多程序员认为 Java 程序设计语言对对象采用的是引用调用，但事实上这种理解是不对的</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*编写一个雇员交换的方法*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(Employee x,Employee y)</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">Employee</span> <span class="variable">temp</span> <span class="operator">=</span> x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = temp;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果Java采用的是引用调用，那么这个方法就应该能够实现交换数据的效果。但是，方法并没有改变存储在变量中的对象引用。<code>swap()</code>方法交换的是两个对象引用的拷贝。这个过程说明 java 对对象采用的不是引用调用，实际上<strong>对象引用进行的是值传递</strong></p>
</blockquote>
<p>Java 程序设计语言中方法参数的使用情况：</p>
<ul>
<li>一个方法不能修改一个基本数据类型的参数。（即数值型和布尔型）</li>
<li>一个方法可以改变一个对象参数的状态。</li>
<li><strong>一个方法不能让对象参数引用一个新的对象。</strong></li>
</ul>
<ol start="3">
<li>隐式参数与显示参数</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">raiseSalary</span><span class="params">(<span class="type">double</span> byPercent)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">double</span> <span class="variable">raise</span> <span class="operator">=</span> salary * byPercent / <span class="number">100</span>;</span><br><span class="line">	salary+=raise;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//该方法有两个参数，第一个参数为隐式参数，是出现在方法名前的Employee类对象，第二个参数是显式参数</span></span><br></pre></td></tr></table></figure>
<p>在每一个方法中，关键字 <strong>this</strong> 表示隐式参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">raiseSalary</span><span class="params">(<span class="type">double</span> byPercent)</span></span><br><span class="line">{</span><br><span class="line">	<span class="type">double</span> <span class="variable">raise</span> <span class="operator">=</span> <span class="built_in">this</span>.salary * byPercent / <span class="number">100</span>;</span><br><span class="line">	<span class="built_in">this</span>.salary+=raise;		<span class="comment">//这样可以将实例域与局部变量区分开了</span></span><br><span class="line">}   	</span><br></pre></td></tr></table></figure>
<h3 id="局部变量"><a class="markdownIt-Anchor" href="#局部变量"></a> 局部变量</h3>
<p>如果在成员方法内定义一个变量，那么这个变量被称之为局部变量。</p>
<p>局部变量在方法 <strong>执行时被创建</strong> ，在方法执行 <strong>结束时被销毁</strong> 。局部变量在使用时必须进行赋值操作或被初始化</p>
<h2 id="静态域与静态方法"><a class="markdownIt-Anchor" href="#静态域与静态方法"></a> 静态域与静态方法</h2>
<h3 id="静态变量"><a class="markdownIt-Anchor" href="#静态变量"></a> 静态变量</h3>
<p>不同类之间需要对同一个变量进行操作，此变量可作为一个共享变量，该共享变量用 <em><strong>static</strong></em> 修饰，称之为静态变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名.静态类成员</span><br></pre></td></tr></table></figure>
<p>静态变量属于类，不属于任何独立的对象。</p>
<h3 id="静态方法"><a class="markdownIt-Anchor" href="#静态方法"></a> 静态方法</h3>
<p>静态方法不依赖任何对象就还可以直接访问，对于静态方法来说没有 <code>this</code> 关键字。如果想使用类中的成员方法，需要先将这个类实例化，但有时候不想或者无法创建类的对象时，还要调用类中的方法，这样可以使用静态方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名.静态方法();</span><br></pre></td></tr></table></figure>
<p><strong>在静态方法中不能访问类的非静态成员变量和非静态方法。</strong></p>
<p>在下面两种情况使用静态方法：</p>
<ul>
<li>一个方法不需要访问对象状态，其所需参数都是通过显式参数提供（如<code>Math.pow()</code>）</li>
<li>一个方法只需要访问类的静态域</li>
</ul>
<h3 id="静态代码块"><a class="markdownIt-Anchor" href="#静态代码块"></a> 静态代码块</h3>
<p>在类的成员方法之外，用 <code>static</code> 修饰代码区域可以称之为静态代码块。定义一块静态代码块，可以在完成类的初始化操作，在  <strong>类的声明</strong> 时就会运行。</p>
<h3 id="工厂方法"><a class="markdownIt-Anchor" href="#工厂方法"></a> 工厂方法</h3>
<p>静态方法的一种常见用途。使用工厂方法产生不同风格的格式对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NumberFormat</span> <span class="variable">currencyFormatter</span> <span class="operator">=</span> NumberFormat.getCurrencyInstance();</span><br><span class="line"><span class="type">NumberFormat</span> <span class="variable">percentFormatter</span> <span class="operator">=</span> NumberFormat.getPercentInstance();</span><br><span class="line"><span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0.1</span>;</span><br><span class="line">System.out.println(currencyFormatter.format(x));</span><br><span class="line">System.out.println(percentFormatter.format(x));</span><br></pre></td></tr></table></figure>
<h3 id="类的主方法"><a class="markdownIt-Anchor" href="#类的主方法"></a> 类的主方法</h3>
<p>主方法是类的入口点，它指向了程序从何处开始，提供对程序流向的控制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>{</span><br><span class="line"><span class="comment">// 方法体</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<ul>
<li>主方法是静态的，所以如果要在主方法中直接调用其他方法，则该方法必须也是静态的</li>
<li>主方法没有返回值</li>
<li>主方法的形参是数组，其中<code>args[0]~args[n]</code>代表程序的第一个参数到第n+1个参数</li>
</ul>
<h2 id="对象构造"><a class="markdownIt-Anchor" href="#对象构造"></a> 对象构造</h2>
<h3 id="重载"><a class="markdownIt-Anchor" href="#重载"></a> 重载</h3>
<p>多个方法有相同的名字，不同的参数，便产生了重载。编译器通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法。</p>
<blockquote>
<p>不能有两个名字相同，参数类型也相同，却返回不同类型值的方法。</p>
</blockquote>
<h3 id="无参数构造器"><a class="markdownIt-Anchor" href="#无参数构造器"></a> 无参数构造器</h3>
<p>如果在编写一个类时没有编写构造器，那么系统就会提供一个无参数构造器。这个构造器将所有的实例域设置为默认值：数值型数据设置为 <strong>0</strong> ，布尔型数据设置为 <strong>false</strong> ，对象变量设置为 <strong>null</strong></p>
<p>如果类中提供了至少一个构造器，但是没有提供无参数构造器，则在构造对象时如果没有提供参数就会被视为不合法。</p>
<blockquote>
<p>仅当类没有提供任何构造器的时候，系统才会提供一个默认的构造器。</p>
</blockquote>
<h3 id="调用另一个构造器"><a class="markdownIt-Anchor" href="#调用另一个构造器"></a> 调用另一个构造器</h3>
<p>关键字  <code>this</code>  引用方法的隐式参数。</p>
<p><code>this</code>  关键字的另一含义： 如果构造器的第一个语句形如 <code>this(...)</code>  ，这个构造器将调用同一个类的另一个构造器，这样对公共的构造器代码部分只编写一次即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(<span class="type">double</span> s)</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">this</span>(<span class="string">"employee #"</span>+nextId,s);		<span class="comment">//调用Employee(String,double)构造器</span></span><br><span class="line">    nextId++;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="初始化块"><a class="markdownIt-Anchor" href="#初始化块"></a> 初始化块</h3>
<p>初始化数据域的方法：</p>
<ul>
<li>在构造器中设置值</li>
<li>在声明中赋值</li>
<li>初始化块</li>
</ul>
<p>在一个类的声明中，可以包含多个代码块。<strong>只要构造类的对象，这些块就会被执行。</strong></p>
<h3 id="对象析构与finalize方法"><a class="markdownIt-Anchor" href="#对象析构与finalize方法"></a> 对象析构与finalize方法</h3>
<p>Java有自动的垃圾回收器，不需要人工回收内存，所以Java不支持析构器。当对象使用了内存之外的其他资源，当资源不再需要时，需要将其回收。可以为任意一个类添加 <code>finalize</code> 方法，<code>finalize</code>方法将在垃圾回收器清除对象之前调用。</p>
<h2 id="包"><a class="markdownIt-Anchor" href="#包"></a> 包</h2>
<p>借助包可以方便地组织自己的代码，并将自己的代码与别人提供地代码库分开管理。</p>
<p>使用包的主要原因是确保类名的唯一性。</p>
<h3 id="类的导入"><a class="markdownIt-Anchor" href="#类的导入"></a> 类的导入</h3>
<p>一个类可以使用所属包中的所有类，以及其他包中的公有类（public class）。可以采用两种方式访问另一个包中的公共包：</p>
<ol>
<li>在每个类名之前添加完整的包名</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.util.<span class="type">Date</span> <span class="variable">today</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.util.Date();</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>可以使用 <code>import</code> 语句导入一个特定的类或整个包。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br></pre></td></tr></table></figure>
<h3 id="将类放入包中"><a class="markdownIt-Anchor" href="#将类放入包中"></a> 将类放入包中</h3>
<p>如果没有在源文件中放置<code>packge</code>语句，这个源文件中的类就会被放置在一个默认包中（default  package）。默认包是一个没有名字的包。</p>
<h3 id="包作用域"><a class="markdownIt-Anchor" href="#包作用域"></a> 包作用域</h3>
<p>标记为 <code>public</code> 的部分可以被任意的类使用；标记为 <code>private</code> 的部分只能被定义它们的类使用。如果没有指定 <code>public</code> 和 <code>private</code> ，这个部分（类，方法或变量）可以被同一个包中的所有方法访问。</p>
<h2 id="文档注释"><a class="markdownIt-Anchor" href="#文档注释"></a> 文档注释</h2>
<h3 id="注释的插入"><a class="markdownIt-Anchor" href="#注释的插入"></a> 注释的插入</h3>
<p>javadoc实用程序从下面几个特性中抽取信息：</p>
<ul>
<li>包</li>
<li>公有类与接口</li>
<li>共有的和受保护的构造器及方法</li>
<li>公有的和受保护的域</li>
</ul>
<p>应该为这几部分编写注释，注释以<code>/**</code>开始，并以<code>*/</code>结束</p>
<h3 id="方法注释"><a class="markdownIt-Anchor" href="#方法注释"></a> 方法注释</h3>
<p>每一个方法注释必须放在所描述的方法之前。</p>
<ul>
<li>**@param **变量描述</li>
<li><strong>@return</strong> 描述</li>
<li><strong>@throw</strong> 类描述</li>
</ul>
<h3 id="通用注释"><a class="markdownIt-Anchor" href="#通用注释"></a> 通用注释</h3>
<ul>
<li><strong>@author</strong> 姓名</li>
<li><strong>@version</strong> 版本</li>
</ul>
<h1 id="继承"><a class="markdownIt-Anchor" href="#继承"></a> 继承</h1>
<h2 id="类超类和子类"><a class="markdownIt-Anchor" href="#类超类和子类"></a> 类，超类和子类</h2>
<p>已存在的类称为超类，父类或基类；新类称为子类，派生类或孩子类。</p>
<ol>
<li><code>extends</code> 关键字</li>
</ol>
<p>在 Java 中，让一个类继承另一个类需要使用 <code>extends</code> 关键字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Child <span class="keyword">extends</span> <span class="title class_">Parents</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Java 只支持单继承，即 <strong>一个类只可以有一个父类</strong>，且所有的继承都是公有继承</li>
</ul>
<p>2.方法的重写</p>
<p>当父类中的某个方法并不适用于子类时，就需要在子类中重写父类的这个方法。</p>
<p>重写就是在子类中将父类的成员方法名称保留，重新编写父类成员方法的实现内容，更改成员方法的存储权限或者修改成员方法的返回值类型</p>
<blockquote>
<p>当重写父类方法时，修改方法的修饰权限只能 <strong>从小范围到大范围</strong> 改变</p>
</blockquote>
<ol start="3">
<li><code>super</code> 关键字</li>
</ol>
<ul>
<li>子类重写了父类的方法后需要调用父类的方法，需要用到 <strong><code>super</code></strong> 关键字，<strong><code>super</code></strong> 代表父类对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">super</span>.property; <span class="comment">//调用父类的属性</span></span><br><span class="line"><span class="built_in">super</span>.method(); <span class="comment">//调用父类的方法</span></span><br></pre></td></tr></table></figure>
<ul>
<li>调用超类的构造器</li>
</ul>
<h3 id="多态"><a class="markdownIt-Anchor" href="#多态"></a> 多态</h3>
<p>在Java中，多态的含义是”一种定义，多种实现“。 类的多态可以从两方面体现：一是方法的重载，二是类的上下转型</p>
<ol>
<li>方法的重载</li>
</ol>
<p>方法的重载就是在同一个类中存在多个同名方法，只要这些方法的参数个数或者类型不同即可</p>
<ol start="2">
<li>向上转型</li>
</ol>
<p>把子类对象赋值给父类类型的对象</p>
<ol start="3">
<li>向下转型</li>
</ol>
<p>将父类对象强制转换为子类对象（显示类型转换）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Quadrangle</span> <span class="variable">q</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Parallelogram</span>();</span><br><span class="line"><span class="type">Parallelogram</span> <span class="variable">p</span> <span class="operator">=</span> (Parallelogram) q; <span class="comment">//将父类对象赋予子类对象，并强制转换为子类型</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li><code>instanceof</code> 关键字</li>
</ol>
<p>在程序执行向下转换操作时，如果父类对象不是子类的实例，就会发生ClassCastException异常，所以在执行向下转型之前需要使用 <code>instanceof</code> 关键字判断父类对象是否为子类的实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myobject <span class="keyword">instanceof</span> ExampleClass	<span class="comment">//返回值为布尔型</span></span><br></pre></td></tr></table></figure>
<ul>
<li>myobject：某类的对象引用</li>
<li>ExampleClass：某个类</li>
</ul>
<h3 id="阻止继承final类和方法"><a class="markdownIt-Anchor" href="#阻止继承final类和方法"></a> 阻止继承：final类和方法</h3>
<p>不允许扩展的类被称为 <strong>final</strong> 类。类中的特定方法也可以被声明为 <strong>final</strong> 。这样子类就不能覆盖这个方法。（<strong>final 类中的所有方法自动地成为 final 方法</strong>）将方法或类声明为 final 主要的目的是：确保它们不会在子类中改变语义。被final修饰的类，方法，变量不能被改变。</p>
<ol>
<li>final 类</li>
</ol>
<p>被 final 修饰的类不能 <strong>被继承</strong> 。当把某个类设置为final 类时，类中的所有方法都隐式的被设置为 final 形式，但是 final 类中的成员变量即可以定义为 final 形式，也可以定义为非 final 形式</p>
<ol start="2">
<li>final方法</li>
</ol>
<p>被 final 修饰的方法不能被 <strong>重写</strong> 。一个定义为 <code>private</code> 的方法隐式的被指定为final类型</p>
<ol start="3">
<li>final变量</li>
</ol>
<p>final 修饰的变量不能被修改，也称为常量。final 修饰的变量必须在声明时对其进行赋值操作</p>
<h3 id="抽象类与抽象方法"><a class="markdownIt-Anchor" href="#抽象类与抽象方法"></a> 抽象类与抽象方法</h3>
<p>在Java中，<strong>抽象类不能产生对象实例</strong> 。定义抽象类时，需要使用 <code>abstract</code> 关键字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*抽象类*/</span></span><br><span class="line">[权限修饰符] <span class="keyword">abstract</span> 类名{</span><br><span class="line">类体</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*抽象方法*/</span></span><br><span class="line">[权限修饰符] <span class="keyword">abstract</span> 方法返回值类型 方法名(参数列表);</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下以person类为例</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String n)</span></span><br><span class="line">    {</span><br><span class="line">        name = n;</span><br><span class="line">	}</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">getDescription</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>抽象方法本身没有任何意义，除非被重写。<strong>抽象类除了被继承外没有任何意义</strong>，继承抽象类的所有子类都需要重写抽象类中的抽象方法。</p>
<blockquote>
<p><strong>构造方法不能定义为抽象方法</strong></p>
</blockquote>
<h3 id="访问控制"><a class="markdownIt-Anchor" href="#访问控制"></a> 访问控制</h3>
<p>java用于控制可见性的4个访问修饰符：</p>
<ol>
<li>仅本类可见——<code>private</code></li>
<li>对所有类可见——<code>public</code></li>
<li>对本包和所有子类可见——<code>protected</code></li>
<li>对本包可见——默认</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>public</th>
<th>protected</th>
<th>default（缺省）</th>
<th>private</th>
</tr>
</thead>
<tbody>
<tr>
<td>本类</td>
<td>可见</td>
<td>可见</td>
<td>可见</td>
<td>可见</td>
</tr>
<tr>
<td>本类所在的包</td>
<td>可见</td>
<td>可见</td>
<td>可见</td>
<td>不可见</td>
</tr>
<tr>
<td>其他包的子类</td>
<td>可见</td>
<td>可见</td>
<td>不可见</td>
<td>不可见</td>
</tr>
<tr>
<td>其他包的非子类</td>
<td>可见</td>
<td>不可见</td>
<td>不可见</td>
<td>不可见</td>
</tr>
</tbody>
</table>
<h3 id="接口的声明及实现"><a class="markdownIt-Anchor" href="#接口的声明及实现"></a> 接口的声明及实现</h3>
<p>接口是抽象类的延伸，接口中的所有方法都没有方法体。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] interface 接口名 [extends 父接口列表]{</span><br><span class="line">	[<span class="keyword">public</span>] [<span class="keyword">static</span>] [<span class="keyword">final</span>] 常量;</span><br><span class="line">	[<span class="keyword">public</span>] [<span class="keyword">abstract</span>] 方法;  <span class="comment">//接口中的方法都是抽象方法，没有方法体</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>一个类实现一个接口可以使用implements 关键字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parallelogram</span> <span class="keyword">implements</span> <span class="title class_">drawTest</span>{</span><br><span class="line">  ……</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<ul>
<li>在接口中定义的任何变量都是自动是final和static的，因此在接口定义变量时，必须进行初始化</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.imageio.stream.ImageInputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">drawImage</span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">implements</span> <span class="title class_">drawImage</span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>{</span><br><span class="line">        System.out.println(<span class="string">"画矩形"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">implements</span> <span class="title class_">drawImage</span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>{</span><br><span class="line">        System.out.println(<span class="string">"画正方形"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Diamond</span> <span class="keyword">implements</span> <span class="title class_">drawImage</span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>{</span><br><span class="line">        System.out.println(<span class="string">"画菱形"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpecialParallelogram</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        drawImage[] images = {<span class="keyword">new</span> <span class="title class_">Rectangle</span>(),<span class="keyword">new</span> <span class="title class_">Square</span>(),<span class="keyword">new</span> <span class="title class_">Diamond</span>()};</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;images.length;i++)</span><br><span class="line">            images[i].draw();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="多重继承"><a class="markdownIt-Anchor" href="#多重继承"></a> 多重继承</h3>
<p>在 Java 中不允许多重继承，但使用接口可以实现多重继承，因为一个类可以实现多个接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ass 类名 implements 接口<span class="number">1</span>，接口<span class="number">2</span>，……，接口n</span><br></pre></td></tr></table></figure>
<ul>
<li>抽象类与接口的区别</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">比较项</th>
<th style="text-align:left">抽象类</th>
<th style="text-align:left">接口</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">方法</td>
<td style="text-align:left">可以有非抽象方法</td>
<td style="text-align:left">所有方法都是抽象方法</td>
</tr>
<tr>
<td style="text-align:center">属性</td>
<td style="text-align:left">属性可以有非静态常量</td>
<td style="text-align:left">所有属性都是静态常量</td>
</tr>
<tr>
<td style="text-align:center">构造方法</td>
<td style="text-align:left">有构造方法</td>
<td style="text-align:left">没有构造方法</td>
</tr>
<tr>
<td style="text-align:center">继承</td>
<td style="text-align:left">一个类只能继承一个父类</td>
<td style="text-align:left">一个类可以同时实现多个接口</td>
</tr>
<tr>
<td style="text-align:center">被继承</td>
<td style="text-align:left">一个类只能继承一个父类</td>
<td style="text-align:left">一个类可以同时实现多个接口</td>
</tr>
</tbody>
</table>
<h2 id="所有类的父类object"><a class="markdownIt-Anchor" href="#所有类的父类object"></a> 所有类的父类——Object</h2>
<p>Object类是Java所有类的始祖，在Java中每个类都是由它扩展而来。</p>
<p>可以使用Object类型的变量引用任何类型的对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">"Harry Hacker"</span>,<span class="number">35000</span>);</span><br></pre></td></tr></table></figure>
<p>Object类型的变量只能作为各种值的通用持有者，要想对其中的内容进行具体的操作，<strong>还需要进行相应的类型转换</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Employee</span> <span class="variable">e</span> <span class="operator">=</span> (Employee) obj;</span><br></pre></td></tr></table></figure>
<p><strong>所有的数组类型，不管是对象数组还是基本类型数组都扩展了Object类。</strong></p>
<p>在Object类中主要包括 <code>clone()</code> 、<code>finalize()</code>、 <code>equals()</code> 、 <code>toString()</code> 等方法，其中常用的两个方法为 <code>equals()</code> 、 <code>toString()</code> 方法。由于所以的类都是Object类的子类，所以任何类都可以重写Object类中的方法</p>
<blockquote>
<p>Object类中的 <code>getClass()</code>、  <code>notify()</code>、  <code>notifyAll()</code>、 <code>wait()</code>  等方法不能被重写，因为这些方法被定义为 <strong>final</strong> 类型</p>
</blockquote>
<h3 id="equals-方法"><a class="markdownIt-Anchor" href="#equals-方法"></a> equals() 方法</h3>
<p>Object类中的<code>equals()</code> 方法用于检测一个对象是否等于另一个对象。在Object类中的，<code>equals()</code> 方法比较的是两个对象的引用是否相等，如果两个对象具有相同的引用，它们一定是相等的。然而经常需要检测两个对象状态的相等性，如果两个对象的状态相等，就认为这两个对象是相等的。</p>
<p>编写一个完美的 <code>equals</code> 方法：</p>
<ol>
<li>显示参数命名为otherObject，稍后需要将它转换成另一个叫做other的变量。</li>
<li>检测 this 与 otherObject是否引用同一个对象：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span> == otherObject)  <span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>检测otherObject是否为null，如果为null，返回false。这项检测很有必要。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (otherObject == <span class="literal">null</span>)` <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>比较this与otherObject是否属于同一个类。如果 equals 的语句在每个子类中有所改变，就使用 <code>getClass</code> 检测：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(getClass() != otherObject.getClass())  <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>如果所有子类都拥有统一的语义，就是用 <code>instanceof</code> 检测：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!(otherObject <span class="keyword">instanceof</span> ClassName))	 <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>将otherObject转换为相应的类类型变量：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassName</span> <span class="variable">other</span> <span class="operator">=</span> (ClassName)otherObject;</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>对所有需要比较的域进行比较：使用 <code>==</code> 比较基本数据类型，使用 <code>equals</code> 比较对象域</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> field1 == other.field1</span><br><span class="line">	&amp;&amp;Objects.equals(field2,other.field2) </span><br><span class="line">	&amp;&amp;...</span><br></pre></td></tr></table></figure>
<h3 id="hashcode方法"><a class="markdownIt-Anchor" href="#hashcode方法"></a> HashCode方法</h3>
<p>散列码是由对象导出的一个整型值，每个对象都有一个默认的散列码，其值为对象的存储地址。Equals与hashCode的定义必须一致。</p>
<h3 id="tostring-方法"><a class="markdownIt-Anchor" href="#tostring-方法"></a> toString() 方法</h3>
<p><code>toString()</code> 方法会返回某个对象的字符串表示形式。绝大多数 <code>toString()</code>都遵循这样的格式：类的名字，随后是一对方括号括起来的域值。</p>
<p>当打印某个对象时，或只要某个对象与一个字符串通过操作符 ”+“ 连接起来时，Java编译器将自动调用重写的 <code>toString()</code> 方法以便获得这个对象的字符串描述。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Point</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">"The current position is "</span> + p;</span><br></pre></td></tr></table></figure>
<p>数组 <code>toString</code> 方法的使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>};</span><br><span class="line">System.out.println(Arrays.toString(nums));</span><br><span class="line"><span class="comment">// 将打印字符串  [1, 2, 3, 4, 5, 6] </span></span><br></pre></td></tr></table></figure>
<h2 id="泛型数组列表"><a class="markdownIt-Anchor" href="#泛型数组列表"></a> 泛型数组列表</h2>
<p>在许多程序设计语言中，必须在编译时就确定整个数组的大小。在Java中，它允许在运行时确定数组大小。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">actualSize</span> <span class="operator">=</span> ...;</span><br><span class="line">Employee[] staff = <span class="keyword">new</span> <span class="title class_">Employee</span>[actualSize];</span><br><span class="line"><span class="comment">//这段代码并没有完全解决运行时动态更改数组的问题。一旦确定了数组大小，不能轻易改变。解决这个问题最简单的方法是使用ArrayList类</span></span><br><span class="line">ArrayList&lt;Employee&gt; staff = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>ArrayList是一个采用类型参数的泛型类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;T&gt;()						<span class="comment">//构造一个空数组列表</span></span><br><span class="line">ArrayList&lt;T&gt;(<span class="type">int</span> initialCapacity)	<span class="comment">//用指定容量构造一个空数组列表</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">add</span><span class="params">(T obj)</span>					<span class="comment">//在数组列表尾端添加一个元素。永远返回true</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>							<span class="comment">//返回存储在数组列表中当前元素的数量</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">trimToSize</span><span class="params">()</span>					<span class="comment">//将数组列表的存储容量削尖到当前尺寸</span></span><br></pre></td></tr></table></figure>
<h3 id="访问数组列表元素"><a class="markdownIt-Anchor" href="#访问数组列表元素"></a> 访问数组列表元素</h3>
<p>ArrayList 使用 get 和 set 方法实现访问或改变数组元素的操作。</p>
<p>要设置第 i 个元素，可以使用：</p>
<p><code>staff.set(i,harry)</code>               它等价于对数组a的元素赋值：<code>a[i]=harry</code></p>
<blockquote>
<p>使用 add 方法为数组添加新元素，而不要使用 set 方法，他只能替换数组中已经存在的元素内容</p>
</blockquote>
<p>获得数组列表的元素：</p>
<p><code>Employee e = staff.get(i)</code>    等价于：<code>Employee e = a[i]</code></p>
<p>下面这个技巧可以一举两得，既可以灵活地扩展数组，又可以方便地访问数组元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先创建一个数组，并添加所有的元素</span></span><br><span class="line"><span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span>(...)</span><br><span class="line">{</span><br><span class="line">    x = ...;</span><br><span class="line">    list.add(x)；</span><br><span class="line">}</span><br><span class="line"><span class="comment">//使用toArray方法将数组元素拷贝到一个数组中</span></span><br><span class="line">X[] a = <span class="keyword">new</span> <span class="title class_">X</span>[list.size()];</span><br><span class="line">list.toArray(a);</span><br></pre></td></tr></table></figure>
<ul>
<li>java.util.ArrayList&lt;T&gt; 1.2</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> index,T obj)</span></span><br><span class="line">T <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index,T obj)</span>       <span class="comment">//向后移动元素，以便插入元素</span></span><br><span class="line">T <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span>				<span class="comment">//删除元素，并将后面的元素向前移动</span></span><br></pre></td></tr></table></figure>
<h2 id="对象包装器与自动装箱"><a class="markdownIt-Anchor" href="#对象包装器与自动装箱"></a> 对象包装器与自动装箱</h2>
<p>所有的基本类型都有一个与之对应的类，这些类称为包装器： <strong>Integer,Long,Double,Short,Byte,Character,Void</strong> 和 <strong>Boolean</strong>（前6个类派生于公共的超类 Number）</p>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>对应的包装类</th>
<th>基本数据类型</th>
<th>对应的包装类</th>
</tr>
</thead>
<tbody>
<tr>
<td>byte</td>
<td>Byte</td>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
<td>boolean</td>
<td>Boolean</td>
</tr>
</tbody>
</table>
<p>对象包装器类是不可变的，即一旦构造了包装器，就不允许更改包装在其中的值，同时对象包装器类还是 <strong>final</strong> ，因此不能定义他们的子类。</p>
<p><code>list.add(3)</code> 将自动地变换成 <code>list.add(Integer.valueOf(3))</code> 这种变换被称为自动装箱。相反地将Integer对象赋给一个int值时，将会自动地拆箱。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*java.lang.Integer 1.0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">intValue</span><span class="params">()</span>							<span class="comment">//以int的形式返回Integer对象的值</span></span><br><span class="line"><span class="keyword">static</span> String <span class="title function_">toString</span><span class="params">(<span class="type">int</span> i)</span>			<span class="comment">//以一个新String对象的形式返回给定数值i的十进制表示</span></span><br><span class="line"><span class="keyword">static</span> String <span class="title function_">toString</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> radix)</span>	<span class="comment">//返回数值i的基于给定radix参数进制的表示</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">parseInt</span><span class="params">(Stringh s)</span>			<span class="comment">//返回字符串s表示的十进制整型数值</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">parseInt</span><span class="params">(Stringh s,<span class="type">int</span> radix)</span><span class="comment">//返回字符串s表示的radix进制整型数值  </span></span><br><span class="line"><span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(String s)</span>		<span class="comment">//返回s表示的十进制整型数值进行初始化的一个新Integer对象</span></span><br><span class="line"><span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(String s)</span>		<span class="comment">//返回s表示的radix进制整型数值进行初始化的一个新Integer对象</span></span><br></pre></td></tr></table></figure>
<p><strong>Integer</strong> 提供了4个常量：</p>
<ul>
<li>[x] MAX_VALUE：表示int类型可取的最大值，即2<sup>31</sup> -1</li>
<li>[x] MIN_VALUE：表示int类型可取的最小值，即-2<sup>31</sup></li>
<li>[x] SIZE：用来以二进制补码形式表示int值的位数</li>
<li>[x] TYPE：表示基本类型int的Class实例</li>
</ul>
<h2 id="参数数量可变的方法"><a class="markdownIt-Anchor" href="#参数数量可变的方法"></a> 参数数量可变的方法</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">system.out.printf(<span class="string">"%d"</span>,n);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*printf的定义如下：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintStrem</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> PrintStrem <span class="title function_">printf</span><span class="params">(String fmt,Object... args)</span></span><br><span class="line">    {       <span class="comment">//这里的...是Java代码的一部分，它表明这个方法可以接收任意数量的对象</span></span><br><span class="line">        <span class="keyword">return</span> format(fmt,args);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>用户可以定义可变参数的方法，并将参数指定为任意类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算若干数值的最大值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">max</span><span class="params">(<span class="type">double</span>... values)</span>	</span><br><span class="line">{</span><br><span class="line">    <span class="type">double</span> <span class="variable">largest</span> <span class="operator">=</span> Double.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">double</span> v:values)</span><br><span class="line">    	<span class="keyword">if</span>(v&gt;largest) largest=v;</span><br><span class="line">   	<span class="keyword">return</span> largest;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用这个方法</span></span><br><span class="line"><span class="type">double</span> <span class="variable">m</span> <span class="operator">=</span> max(<span class="number">3.1</span>,<span class="number">40.4</span>,-<span class="number">5</span>)		<span class="comment">//编译器将new double[]{3.1,40.4,-5}传递给max方法</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>允许将一个数组传递给可变参数方法的最后一个参数</p>
</blockquote>
<h2 id="常用类和枚举类型"><a class="markdownIt-Anchor" href="#常用类和枚举类型"></a> 常用类和枚举类型</h2>
<h3 id="math-类"><a class="markdownIt-Anchor" href="#math-类"></a> Math 类</h3>
<p>Math类中包括许多数学方法，如取最大值，取最小值，取绝对值，三角函数，指数函数和取整函数等，除此之外，Math类还提供了一些数学常量，如PI、E等。</p>
<p>常用数学运算方法：</p>
<ol>
<li>指数函数方法</li>
</ol>
<table>
<thead>
<tr>
<th>方法</th>
<th>返回值</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>exp(double a)</td>
<td>double</td>
<td>用于获取e的a次方</td>
</tr>
<tr>
<td>double log(double a)</td>
<td>double</td>
<td>用于取自然对数</td>
</tr>
<tr>
<td>double log10(double a)</td>
<td>double</td>
<td>用于取底数为10的对数</td>
</tr>
<tr>
<td>sqrt(double a)</td>
<td>double</td>
<td>用于取a的平方根</td>
</tr>
<tr>
<td>abrt(double a)</td>
<td>double</td>
<td>用于取a的立方根</td>
</tr>
<tr>
<td>pow(double a, double b)</td>
<td>double</td>
<td>用去取a的b次方</td>
</tr>
</tbody>
</table>
<ol start="2">
<li>取整函数方法</li>
</ol>
<table>
<thead>
<tr>
<th>方法</th>
<th>返回值</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>ceil(double a)</td>
<td>double</td>
<td>返回大于或等于参数的最小整数</td>
</tr>
<tr>
<td>floor(double a)</td>
<td>double</td>
<td>返回小于或等于参数的最大整数</td>
</tr>
<tr>
<td>rint(double a)</td>
<td>double</td>
<td>返回与参数最接近的整数，如果两个同为整数且相同接近，则结果取偶数</td>
</tr>
<tr>
<td>round(float a)</td>
<td>int</td>
<td>将参数加上0.5后返回小于或等于参数的最大int值</td>
</tr>
<tr>
<td>round(double a)</td>
<td>long</td>
<td>将参数加上0.5后返回小于或等于参数的最大long值</td>
</tr>
</tbody>
</table>
<p><img src="https://teksab-blog-img.oss-cn-guangzhou.aliyuncs.com/img/Java%20EE/202209191102533.png" alt="Math取整函数示例"></p>
<ol start="3">
<li>取最大值、最小值，绝对值函数方法</li>
</ol>
<table>
<thead>
<tr>
<th>方法</th>
<th>返回值</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>max(double a, double b)</td>
<td>double</td>
<td>取a与b之间的最大值</td>
</tr>
<tr>
<td>min(double a, double b)</td>
<td>double</td>
<td>取a与b之间的最大值</td>
</tr>
<tr>
<td>abs(double a)</td>
<td>double</td>
<td>返回参数的绝对值</td>
</tr>
</tbody>
</table>
<h3 id="random类"><a class="markdownIt-Anchor" href="#random类"></a> Random类</h3>
<table>
<thead>
<tr>
<th>方法</th>
<th>返回值</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>nextInt()</td>
<td>int</td>
<td>返回一个随机int值</td>
</tr>
<tr>
<td>nextInt(int n)</td>
<td>int</td>
<td>返回一个大于等于0，小于n的随机数</td>
</tr>
<tr>
<td>nextLong()</td>
<td>long</td>
<td>返回一个随机long值</td>
</tr>
<tr>
<td>nextBoolean()</td>
<td>boolean</td>
<td>返回一个随机boolean值</td>
</tr>
<tr>
<td>nextFloat()</td>
<td>float</td>
<td>返回一个随机float值</td>
</tr>
<tr>
<td>nextDouble()</td>
<td>double</td>
<td>返回一个随机double值</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*模拟微信抢红包*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedBags</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">"***模拟微信抢红包***"</span>);</span><br><span class="line">        System.out.println(<span class="string">"请输入红包总金额："</span>);</span><br><span class="line">        <span class="type">double</span> totalMoney=sc.nextDouble();</span><br><span class="line">        System.out.println(<span class="string">"请输入红包个数："</span>);</span><br><span class="line">        <span class="type">int</span> bagsNum=sc.nextInt();</span><br><span class="line">        <span class="type">double</span> minMoney=<span class="number">0.01</span>;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="keyword">if</span>(totalMoney/bagsNum==<span class="number">0.01</span>){</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;bagsNum;i++){</span><br><span class="line">                <span class="type">double</span> money=minMoney;</span><br><span class="line">                totalMoney-=money;</span><br><span class="line">                System.out.println(<span class="string">"第"</span>+i+<span class="string">"红包："</span>+String.format(<span class="string">"%.2f"</span>,money)+<span class="string">"元"</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(totalMoney/bagsNum&lt;=<span class="number">0.01</span>){</span><br><span class="line">            System.out.println(<span class="string">"要保证每个人都能分到一分钱哦！"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span>{</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;bagsNum;i++){</span><br><span class="line">                <span class="type">double</span> maxMoney=totalMoney-(bagsNum-i)*minMoney;</span><br><span class="line">                <span class="type">double</span> bound=maxMoney-minMoney;  <span class="comment">//设置随机金额的取值范围</span></span><br><span class="line">                <span class="type">double</span> randomMoney=(<span class="type">double</span>) random.nextInt((<span class="type">int</span>) (bound*<span class="number">100</span>))/<span class="number">100</span>;</span><br><span class="line">                <span class="type">double</span> money=minMoney+randomMoney;</span><br><span class="line">                totalMoney-=money;</span><br><span class="line">                System.out.println(<span class="string">"第"</span>+i+<span class="string">"红包："</span>+String.format(<span class="string">"%.2f"</span>,money)+<span class="string">"元"</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"第"</span>+bagsNum+<span class="string">"红包："</span>+String.format(<span class="string">"%.2f"</span>,totalMoney)+<span class="string">"元"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="date-类"><a class="markdownIt-Anchor" href="#date-类"></a> Date 类</h3>
<table>
<thead>
<tr>
<th>方法</th>
<th>返回值</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>after(Date when)</td>
<td>boolean</td>
<td>测试当前日期是否在指定的日期之后</td>
</tr>
<tr>
<td>before(Date when)</td>
<td>boolean</td>
<td>测试当前日期是否在指定的日期之前</td>
</tr>
<tr>
<td>getTime()</td>
<td>long</td>
<td>获得自1970年1月1日 00:00:00 GMT开始到现在所表示的毫秒数</td>
</tr>
<tr>
<td>setTime(long time)</td>
<td>long</td>
<td>设置当前Date对象所表示的日期时间值，该值用以表示1970年1月1日 00:00:00 GMT以后time毫秒的时间点</td>
</tr>
</tbody>
</table>
<p>使用DateFormat类可以定义日期，时间格式。由于DateFormat类是抽象类，因此需要使用DateFormat类的静态方法getDateInstance()创建DateFormat类对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DateFormat</span> <span class="variable">df</span> <span class="operator">=</span> DateFormat.getDateInstance();</span><br></pre></td></tr></table></figure>
<h3 id="枚举类型"><a class="markdownIt-Anchor" href="#枚举类型"></a> 枚举类型</h3>
<p>枚举类型常被用于设置常量。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Constants{</span><br><span class="line">	Constants_A,Constants_B</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>在程序中可以通过Constants.Constants_A的方式使用枚举类型的常量。</p>
<p>所有的枚举类型都是Enum类的子类，他们继承这个类的许多方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">java.lang.Enum&lt;E&gt; 5.0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> Enum <span class="title function_">valueOf</span><span class="params">(Class enumClass,String name)</span><span class="comment">//返回指定名字，给定类的枚举常量</span></span><br><span class="line">String <span class="title function_">toString</span><span class="params">()</span>								<span class="comment">//返回枚举常量名</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ordinal</span><span class="params">()</span>									<span class="comment">//返回枚举常量在enum声明的位置，位置从0开始计数</span></span><br></pre></td></tr></table></figure>
<h2 id="反射"><a class="markdownIt-Anchor" href="#反射"></a> 反射</h2>
<p>能够分析类能力的程序称为反射。反射机制可以用来：</p>
<ul>
<li>在运行时分析类的能力</li>
<li>在运行时查看对象，例如，编写一个toString方法供所有类使用</li>
<li>实现通用的数组操作代码</li>
<li>利用Methon对象，这个对象很像C++中的函数指针</li>
</ul>
<h1 id="接口与内部类"><a class="markdownIt-Anchor" href="#接口与内部类"></a> 接口与内部类</h1>
<p>接口技术主要用来描述类具有什么功能，而并不给出每个功能的具体实现。对象的克隆是指创建一个新对象，且新对象的状态和原始对象的状态相同；当对新对象进行修改时，不会影响原对象的状态。</p>
<h2 id="接口"><a class="markdownIt-Anchor" href="#接口"></a> 接口</h2>
<p>在 Java 程序设计语言中，接口不是类，而是对类的一组需求描述，这些类要遵从接口描述的统一格式进行定义。</p>
<p><strong>接口中的所有方法自动地属于</strong> <strong>public</strong> ，因此在接口声明方法时，不必提供关键字 public，但在实现接口的某个类中，必须把方法声明为 public。</p>
<p>为了让类实现一个接口，通常需要下面两个步骤：</p>
<ol>
<li>将类声明为实现给定的接口</li>
<li>对接口中的所有方法进行定义</li>
</ol>
<p>要将类声明为实现某个接口，需要关键字 <code>implements</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Emoployee</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span></span><br></pre></td></tr></table></figure>
<h3 id="接口的特性"><a class="markdownIt-Anchor" href="#接口的特性"></a> 接口的特性</h3>
<p><strong>接口不能含有实例域</strong>，<strong>接口不是类，也不能使用 <code>new</code> 运算符实例化一个接口</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="keyword">new</span> <span class="title class_">Comparable</span>(...);</span><br></pre></td></tr></table></figure>
<p>可以声明接口的变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Comparable x;</span><br><span class="line">x = <span class="keyword">new</span> <span class="title class_">Employee</span>(...);</span><br></pre></td></tr></table></figure>
<p>接口变量必须是实现类接口的类对象，可以使用 instanceof 检查一个对象是否实现了某个特定的接口:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(anObject <span class="keyword">instanceof</span> Comparable){...}</span><br></pre></td></tr></table></figure>
<p>与类的继承关系一样，接口也可以被扩展。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Moveable</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">move</span><span class="params">(<span class="type">double</span> x,<span class="type">double</span> y)</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Powered</span> <span class="keyword">extends</span> <span class="title class_">Moveable</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">double</span> <span class="title function_">milesPerGallon</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="接口与抽象类"><a class="markdownIt-Anchor" href="#接口与抽象类"></a> 接口与抽象类</h3>
<p>每个类只能扩展于一个类。假设Employee类已经扩展于一个类，如Person，他就不能再扩展第二个类了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">extends</span> <span class="title class_">Person</span>,Comparable;	<span class="comment">//错误</span></span><br></pre></td></tr></table></figure>
<p>但每个类可以实现多个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">extends</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>;</span><br></pre></td></tr></table></figure>
<p>Java 不支持多继承，但接口可以提供多重继承的大多数好处，同时还能避免多重继承的复杂性和低效性。</p>
<h3 id="对象克隆"><a class="markdownIt-Anchor" href="#对象克隆"></a> 对象克隆</h3>
<p>当拷贝一个变量时，原始变量与拷贝变量引用同一个对象，也就是说改变一个变量所引用的对象将会对另一个变量产生影响。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Employee</span> <span class="variable">original</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">"John Public"</span>,<span class="number">5000</span>);</span><br><span class="line"><span class="type">Employee</span> <span class="variable">copy</span> <span class="operator">=</span> original;</span><br><span class="line">copy.raiseSalary(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>如果创建一个对象的新的 copy，它的最初状态与 original  一样，但以后将可以各自改变各自的状态，那就需要使用 <code>clone</code> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Employee</span> <span class="variable">copy</span> <span class="operator">=</span> original.clone();</span><br><span class="line">copy.raiseSalary(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>默认的克隆操作是 <strong>浅拷贝</strong>，它并没有克隆包含在对象中的内部对象。（只是将各个域进行对应的拷贝，如果在对象中包含对子对象的引用，拷贝的结果会使得两个域引用同一个子对象，因此原始对象与克隆对象共享这部分信息）如果原始对象与浅克隆对象共享的子对象是不可变的，将不会产生任何问题。（如子对象属于像 String 类这样的不允许改变的类）</p>
<p>然而更常见的情况是子对象可变，因此必须重新定义 clone 方法，以便实现克隆子对象的 <strong>深拷贝</strong>。</p>
<p>对于每一个类，都需要做出下列判断：</p>
<ol>
<li>默认的 clone 方法是否满足要求</li>
<li>默认的 clone 方法是否能够通过调用可变子对象的 clone 得到修补</li>
<li>是否不应该使用 clone</li>
</ol>
<p>实际上，选项 3 是默认的。如果要选择 1 或 2，类必须：</p>
<ol>
<li>实现 Cloneable 接口</li>
<li>使用 public 访问修饰符重新定义 clone 方法</li>
</ol>
<blockquote>
<p>子类只能调用受保护的 clone 方法克隆自己，为此必须重新定义 clone 方法，并将它声明为 public ，这样才能让所有的方法克隆对象</p>
</blockquote>
<p>即使 clone 的默认实现（浅拷贝）能够满足需求，也应该实现 Cloneable 接口，将 clone 重新定义为 public ，并调用 <code>super.clone()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*浅拷贝，只是将这个方法声明为 public */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> Employee <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throw</span> CloneNotSupportedException</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> (Employee) <span class="built_in">super</span>.clone();</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*深拷贝*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> Employee <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throw</span> CloneNotSupportedException</span><br><span class="line">    {</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">cloned</span> <span class="operator">=</span> (Employee) <span class="built_in">super</span>.clone();</span><br><span class="line">        cloned.hireDay = (Date) hireDay.clone();	<span class="comment">//为了实现深拷贝，必须克隆所有可变的实例域</span></span><br><span class="line">        <span class="keyword">return</span> cloned;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="接口与回调"><a class="markdownIt-Anchor" href="#接口与回调"></a> 接口与回调</h3>
<p>回调是一种常见的程序设计模式。在这种模式中，可以指定某个特定事件发生时应该采取的动作。例如，可以指定在按下鼠标或选择某个菜单项时应该采取什么行动。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> timer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> javax.swing.Timer;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionListener;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimerTest</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="type">ActionListener</span> <span class="variable">listener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimePrinter</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Timer</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>(<span class="number">10000</span>,listener);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        JOptionPane.showMessageDialog(<span class="literal">null</span>,<span class="string">"Quit program"</span>);</span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TimePrinter</span> <span class="keyword">implements</span> <span class="title class_">ActionListener</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent event)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        System.out.println(<span class="string">"At the tone, the time is"</span>+now);</span><br><span class="line">        Toolkit.getDefaultToolkit().beep();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="lambda表达式"><a class="markdownIt-Anchor" href="#lambda表达式"></a> lambda表达式</h2>
<p>lambda表达式是一个可传递的代码块，可以在以后执行一次或多次。</p>
<h3 id="语法"><a class="markdownIt-Anchor" href="#语法"></a> 语法</h3>
<p>参数，箭头(-&gt;)以及一个表达式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(String first,String second)</span><br><span class="line">	-&gt;first.length()-second.length()</span><br></pre></td></tr></table></figure>
<p>如果代码要完成的计算无法放在一个表达式中，可以像写方法一样，把代码放在 <code>{}</code> 中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(String first,String second)-&gt;</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(first.length()&lt;second.length())	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(first.length()&gt;second.length())	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="内部类"><a class="markdownIt-Anchor" href="#内部类"></a> 内部类</h2>
<p>内部类是定义在另一个类中的类。使用内部类的原因：</p>
<ul>
<li>内部类方法可以访问该类定义所在的的作用域中的数据，包括私有数据</li>
<li>内部类可以对同一个包中的其他类隐藏</li>
<li>当想要定义一个回调函数且不想白编写大量代码时，使用<code>匿名</code>内部类比较便捷</li>
</ul>
<h3 id="使用内部类访问对象状态"><a class="markdownIt-Anchor" href="#使用内部类访问对象状态"></a> 使用内部类访问对象状态</h3>
<p>内部类既可以访问自身的数据域，也可以访问创建它的外围类对象的数据域。</p>
<p>内部类的对象总有一个隐式引用 outer ，它指向创建它的外部类对象。</p>
<blockquote>
<p>outer 不是 Java 的关键字，只是用它说明内部类中的机制</p>
</blockquote>
<h3 id="内部类的特殊语法规则"><a class="markdownIt-Anchor" href="#内部类的特殊语法规则"></a> 内部类的特殊语法规则</h3>
<p>外围类的引用的表达式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OutClass.<span class="built_in">this</span></span><br></pre></td></tr></table></figure>
<p>内部类构造器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outer.new.InnerClass(construction parameters)</span><br></pre></td></tr></table></figure>
<h3 id="匿名内部类"><a class="markdownIt-Anchor" href="#匿名内部类"></a> 匿名内部类</h3>
<p>加入只需要创建局部内部类的一个对象，就不必命名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">SuperType</span>(construction parameters)</span><br><span class="line">{</span><br><span class="line">    inner <span class="keyword">class</span> <span class="title class_">methods</span> and data</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="静态内部类"><a class="markdownIt-Anchor" href="#静态内部类"></a> 静态内部类</h3>
<p>使用内部类就是为了把一个类隐藏在另一个类的内部，并不需要内部类引用外围对象。为此，可以将内部类声明为static ，以便取消产生的引用。</p>
<h2 id="代理"><a class="markdownIt-Anchor" href="#代理"></a> 代理</h2>
<p>利用代理可以在运行时创建一个实现了一组给定接口的新类。</p>
<h1 id="异常-断言-日志和调试"><a class="markdownIt-Anchor" href="#异常-断言-日志和调试"></a> 异常、断言、日志和调试</h1>
<p>在Java中，异常就是程序运行时产生的错误。如像一个不存在的文本文件写入数据时，就会产生FileNotFoundException异常(系统找不到文件)。</p>
<p>当程序执行到某一方法处产生异常时，JVM就会产生与已产生的异常相匹配的异常对象；如果没有对异常对象做异常处理，那么就会显示异常信息。</p>
<h2 id="处理错误"><a class="markdownIt-Anchor" href="#处理错误"></a> 处理错误</h2>
<p>用户期望在出现错误时，程序能够采用一些理智的行为。如果由于出现错误而使得某些操作没有完成，程序应该：</p>
<ul>
<li>返回到一种安全状态，并能够让用户执行一些其他命令</li>
<li>允许用户保存所有操作的结果，并以适当的方式终止程序</li>
</ul>
<p>异常处理的任务就是将控制权从错误产生的地方转移给能够处理这种情况的错误处理器。</p>
<p>在 Java 中，如果某个方法不能够采用正常的途径完成它的任务，就可以通过另外一个路径退出方法。在这种情况下，方法不返回任何值，而是抛出（throw）一个封装了错误信息的对象。</p>
<h3 id="异常分类"><a class="markdownIt-Anchor" href="#异常分类"></a> 异常分类</h3>
<p>异常对象都是派生于 <strong>Throwable</strong> 类的一个实例。</p>
<p><img src="https://teksab-blog-img.oss-cn-guangzhou.aliyuncs.com/img/Java%20EE/202209191102317.png" alt="Throwable"></p>
<p>Error类层次结构描述了 Java 运行时系统内部错误和资源耗尽错误，应用程序不应该出现抛出这样的对象。在这集 Java 程序时，需要关注 Exception 层次结构。</p>
<p>派生于 RuntimeException 的异常包含下面几种情况：</p>
<ul>
<li>错误的类型转换</li>
<li>数组访问越界</li>
<li>访问空指针</li>
</ul>
<p>不是派生 RuntimeException 的异常包括：</p>
<ul>
<li>试图在文件尾部后面读取数据</li>
<li>试图打开一个不存在的文件</li>
<li>试图根据给定的字符串查找 Class 对象，而这个字符串表示的类并不存在</li>
</ul>
<p>Java 语言规范将派生于 Error 类或 RuntimeException类的所有异常称为 <em>未检查异常</em>，所有其他的异常称为 <em>已检查异常</em>。</p>
<h3 id="声明已检查异常"><a class="markdownIt-Anchor" href="#声明已检查异常"></a> 声明已检查异常</h3>
<p>方法应该在其首部声明所有可能抛出的异常，这样可以从首部反映这个方法可能抛出哪类 <em>已检查的异常</em>。</p>
<p>在自己编写方法时，不必将所有可能抛出的异常都进行声明，在以下4种情况应该抛出异常：</p>
<p>1）调用一个抛出已检查异常的方法，例如 FileInputStream 构造器</p>
<p>2）程序运行过程中发现错误，并且利用 throw 语句抛出一个已检查异常</p>
<p>3）程序出现错误</p>
<p>4）Java 虚拟机和运行时库出现的内部错误</p>
<p>总之，一个方法必须声明所有可能抛出的 <em>已检查异常</em>，而未检查异常要么不可控制，要么就应该避免发生。</p>
<h3 id="如何抛出异常"><a class="markdownIt-Anchor" href="#如何抛出异常"></a> 如何抛出异常</h3>
<p>对于一个已经存在的异常类，将其抛出：</p>
<p>1）找到一个合适的异常类</p>
<p>2）创建这个类的一个对象</p>
<p>3）将对象抛出</p>
<ol>
<li>使用 <strong>throws</strong> 关键字抛出异常</li>
</ol>
<p>throws 关键字常被应用于方法上，表示方法可能抛出的异常，当方法抛出多个异常时，可用逗号分隔异常类型名。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 方法名 (参数表) <span class="keyword">throws</span> 异常类型{</span><br><span class="line">	方法体</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>使用 <strong>throw</strong> 关键字抛出异常</li>
</ol>
<p>throw 关键字虽然可以用于抛出Exception类中的子类异常，但重要的用途是抛出自定义异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> 异常类型名(异常信息)</span><br></pre></td></tr></table></figure>
<p>创建自定义异常时，须继承 RuntimeException 类或者 Exception 类</p>
<ol start="3">
<li><strong>throws</strong> 关键字和 <strong>throw</strong> 关键字的区别</li>
</ol>
<p>（1）throws用在方法声明后面，表示抛出异常由方法的调用者处理；而throw用在方法体内，用来制造一个异常，由方法体内的语句处理</p>
<p>（2）throws是声明这个方法会抛出这种类型的异常，以便使它的调用者知道要捕捉这个异常；而throw是直接抛出一个异常实例</p>
<p>（3）throws表示出现异常的一种可能性，并不一定会产生这些异常；但如果使用throw，就一定会产生某种异常</p>
<h3 id="创建异常类"><a class="markdownIt-Anchor" href="#创建异常类"></a> 创建异常类</h3>
<p>在程序中，有时候会遇到任何标准异常类型都没有能够充分地描述清楚的问题，这个时候可以创建自己的异常类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileFormatException</span> <span class="keyword">extends</span> <span class="title class_">IOException</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileFormatException</span><span class="params">()</span>{}</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileFormatException</span><span class="params">(String gripe)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">super</span>(gripe);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h2 id="捕获异常"><a class="markdownIt-Anchor" href="#捕获异常"></a> 捕获异常</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">{</span><br><span class="line">	<span class="comment">// 程序代码块</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">catch</span>  (Exceptiontype e)</span><br><span class="line">{</span><br><span class="line">	<span class="comment">// 对Exceptiontype的处理</span></span><br><span class="line">} </span><br></pre></td></tr></table></figure>
<blockquote>
<p>try中的”程序代码块“指的是可能产生异常的代码；catch中的”对Exceptiontype的处理“的作用是捕捉并处理已产生的异常类型相匹配的异常对象 e；</p>
</blockquote>
<p>如果在  try 语句块中的任何代码抛出一个在 catch 子句中说明的异常类，那么</p>
<p>1）程序将跳过 <code>try</code> 语句块的其余代码</p>
<p>2）程序将执行 <code>catch</code> 子句中的处理器代码</p>
<p>把可能产生异常的代码放在 try 中，把处理异常对象 e 的代码放在catch中；如果使用了多少catch代码块，则catch代码块中的异常类顺序是 **先子类后父类 **。</p>
<ul>
<li><strong>printStackTrace()</strong> 方法：输出异常信息</li>
<li><strong>getMessage()</strong> 方法：获取有关异常事件的信息</li>
<li><strong>toString()</strong> 方法：获取异常的类型与性质</li>
</ul>
<h3 id="finally-子句"><a class="markdownIt-Anchor" href="#finally-子句"></a> finally 子句</h3>
<p><code>finally</code> 中的”代码块“是异常处理过程中最后被执行的部分，无论程序是否产生异常，<code>finally</code> 中的代码块都将被执行。实际应用中，<code>finally</code> 中通常放置一些释放资源、关闭对象的代码。完整的异常处理语句应该包括 <code>finally</code> 代码块，无论程序中有无异常产生，<code>finally</code> 代码块中的代码都会被执行。</p>
<p>在以下三种特殊情况下，<code>finally</code> 块不会被执行：</p>
<ul>
<li>[x] 在finally代码块中产生了异常</li>
<li>[x] 在前面的代码中使用了System.exit() 退出程序</li>
<li>[x] 程序所在的线程死亡</li>
</ul>
<h3 id="带资源的-try-语句"><a class="markdownIt-Anchor" href="#带资源的-try-语句"></a> 带资源的 try 语句</h3>
<p>带资源的 try 语句（try-with-resourse)的形似：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(Resourse res=...)</span><br><span class="line">{</span><br><span class="line">    work with res</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*以下是一个典型例子，读取一个文件的所有单词*/</span></span><br><span class="line"><span class="keyword">try</span>(<span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">"/usr/share/dict/words"</span>)):</span><br><span class="line">   <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="string">"out.txt"</span>))</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">while</span>(in.hasNext())</span><br><span class="line">        out.println(in.next().toUpperCase());</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>这个块正常退出时，或者存在一个异常时，都会调用 in.close() 方法，就好像使用了 finally块一样。只要需要关闭资源，就要尽可能使用带资源的 try 语句。</p>
<h3 id="分析堆栈跟踪元素"><a class="markdownIt-Anchor" href="#分析堆栈跟踪元素"></a> 分析堆栈跟踪元素</h3>
<p><strong>堆栈跟踪</strong>（stack trace）是一个方法调用过程的列表，它包含了程序执行过程中方法调用的特定位置。使用getStackTrace() 方法可以得到 StackTraceElement 对象的一个数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Throwable</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Throwable</span>();</span><br><span class="line">StackTraceElement[] frames = t.getStackTrace();</span><br><span class="line"><span class="keyword">for</span>(StackTraceElement frame:frames)</span><br><span class="line">    analyze frame</span><br></pre></td></tr></table></figure>
<p>getStackTrace() 类含有能够获得文件名和当前执行的代码行号的方法</p>
<h1 id="泛型程序设计"><a class="markdownIt-Anchor" href="#泛型程序设计"></a> 泛型程序设计</h1>
<p>Java中的参数化类型别称之为泛型。</p>
<p><strong>泛型程序设计</strong>意味着编写的代码可以被很多不同的类型的对象所用。</p>
<h2 id="定义泛型类"><a class="markdownIt-Anchor" href="#定义泛型类"></a> 定义泛型类</h2>
<p>一个泛型类就是具有一个或多个类型变量的类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Pair类*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt;</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T second;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">()</span>{ first = <span class="literal">null</span>; second = <span class="literal">null</span>;}</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(T first, T second)</span>{ <span class="built_in">this</span>.first=first; <span class="built_in">this</span>.second = second;}</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getFirst</span><span class="params">()</span>{ <span class="keyword">return</span> first;}</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getSecond</span><span class="params">()</span>{ <span class="keyword">return</span> second;}</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFirst</span><span class="params">(T newValue)</span>{ first = newValue;}</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSecond</span><span class="params">(T newValue)</span>{ second = newValue;}</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>其中，T代表一个类型变量，用尖括号（&lt; &gt;）括起来，放在类的后面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T,U&gt;{ ... }	<span class="comment">//定义多个类型变量</span></span><br></pre></td></tr></table></figure>
<p>类定义中的类型变量指定方法的返回类型以及域和局部变量的类型。</p>
<h2 id="泛型方法"><a class="markdownIt-Anchor" href="#泛型方法"></a> 泛型方法</h2>
<p>定义一个带有类型参数的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayAlg</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">getMiddle</span><span class="params">(T... a)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> a[a.length/<span class="number">2</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>泛型方法可以定义在普通类中，也可以定义在泛型类中。</p>
<p>调用一个泛型方法时，在方法名前的尖括号中放入具体的类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">middle</span> <span class="operator">=</span> ArrayAlg.&lt;String&gt;getMiddle(<span class="string">"John"</span>,<span class="string">"Q."</span>,<span class="string">"Public"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="类型变量的限定"><a class="markdownIt-Anchor" href="#类型变量的限定"></a> 类型变量的限定</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayAlg</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">min</span><span class="params">(T[] a)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="literal">null</span> || a.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">T</span> <span class="variable">smallest</span> <span class="operator">=</span> a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;a.length;i++)</span><br><span class="line">            <span class="keyword">if</span>(smallest.compareTo(a[i])&gt;<span class="number">0</span>)	smallest = a[i];</span><br><span class="line">        <span class="keyword">return</span> smallest;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>将T限制为实现了 Comparable 接口的类，可以通过对类型变量T设置 <code>限定</code>（bound）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&gt; T <span class="title function_">min</span><span class="params">(T[] a)</span> ...</span><br></pre></td></tr></table></figure>
<p>一个类型变量或通配符可以有多个限定</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T <span class="keyword">extends</span> <span class="title class_">Comparable</span> &amp; Serializable</span><br></pre></td></tr></table></figure>
<h2 id="泛型代码和虚拟机"><a class="markdownIt-Anchor" href="#泛型代码和虚拟机"></a> 泛型代码和虚拟机</h2>
<p>虚拟机没有泛型类型对象——所有对象都属于普通类。无论何时定义一个泛型类型，都自动提供了一个相应的原始类型（ raw type）。原始类型的名字就是删去类型参数后的泛型类型名。擦除（erased）类型变量，并替换为限定类型（无限定的变量用 Object）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Pair类的原始类型*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt;</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">private</span> Object first;		<span class="comment">//因为T是一个无限定的变量，所以直接用Object替换</span></span><br><span class="line">    <span class="keyword">private</span> Object second;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">()</span>{ first = <span class="literal">null</span>; second = <span class="literal">null</span>;}</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(Object first, Object second)</span>{ <span class="built_in">this</span>.first=first; <span class="built_in">this</span>.second = second;}</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getFirst</span><span class="params">()</span>{ <span class="keyword">return</span> first;}</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getSecond</span><span class="params">()</span>{ <span class="keyword">return</span> second;}</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFirst</span><span class="params">(Object newValue)</span>{ first = newValue;}</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSecond</span><span class="params">(Object newValue)</span>{ second = newValue;}</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h3 id="翻译泛型表达式"><a class="markdownIt-Anchor" href="#翻译泛型表达式"></a> 翻译泛型表达式</h3>
<p>当程序调用泛型方法时，如果擦除返回类型，编译器插入强制类型转换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;Employee&gt; buddies = ...;</span><br><span class="line"><span class="type">Employee</span> <span class="variable">buddy</span> <span class="operator">=</span> buddies.getFirst();</span><br></pre></td></tr></table></figure>
<p>擦除 getFirst 的返回类型将返回Object 类型。编译器自动插入Employee的强制类型转换，编译器把这个方法调用翻译为两条虚拟机指令：</p>
<ul>
<li>对原始方法 Pair.getFirst 的调用</li>
<li>将返回的 Object 类型强制类型转换为 Employee 类型</li>
</ul>
<h3 id="翻译泛型方法"><a class="markdownIt-Anchor" href="#翻译泛型方法"></a> 翻译泛型方法</h3>
<p>java泛型转换的事实：</p>
<ul>
<li>虚拟机中没有泛型，只有普通的类和方法、</li>
<li>所有的类型参数都用他们的限定类型替换</li>
<li>桥方法被合成来保持多态</li>
<li>为保持类型安全性，必要时插入类型转换</li>
</ul>
<h2 id="约束与局限性"><a class="markdownIt-Anchor" href="#约束与局限性"></a> 约束与局限性</h2>
<h3 id="不能用基本类型实例化类型参数"><a class="markdownIt-Anchor" href="#不能用基本类型实例化类型参数"></a> 不能用基本类型实例化类型参数</h3>
<p>不能用基本类型实例化类型参数，因此没有 Pair&lt;double&gt;，只有Pair&lt;Double&gt; 。原因是类型擦除，擦除之后，Pair 类含有 Object 类型的域，而 Object 不能存储 <code>double</code> 值。</p>
<h3 id="运行时类型查询只适用于原始类型"><a class="markdownIt-Anchor" href="#运行时类型查询只适用于原始类型"></a> 运行时类型查询只适用于原始类型</h3>
<p>虚拟机中的对象总有一个特定的非泛型类型，因此所有的类型查询只产生原始类型。无论何时使用 **<code>instanceof</code>**及泛型类型的强制转换表达式都会看到一个编译器警告。</p>
<h3 id="不能创建参数化类型的数组"><a class="markdownIt-Anchor" href="#不能创建参数化类型的数组"></a> 不能创建参数化类型的数组</h3>
<p>不能实例化参数化类型的数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt;[] table = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;String&gt;[<span class="number">10</span>];   <span class="comment">//错误使用</span></span><br></pre></td></tr></table></figure>
<p>只是不允许创建这些数组，而声明类型为 <code>Pair\&lt;String\&gt;[]</code> 的变量仍是合法的，不过不能 <code>Pair\&lt;String\&gt;[10]</code> 初始化这个变量。</p>
<h3 id="不能实例化类型变量"><a class="markdownIt-Anchor" href="#不能实例化类型变量"></a> 不能实例化类型变量</h3>
<p>不能使用像 <code>new T(...)</code> ，<code>new T[...]</code> 或 <code>T.class</code> 这样的表达式中的类型变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">()</span> { first = <span class="keyword">new</span> <span class="title class_">T</span>(); second = <span class="keyword">new</span> <span class="title class_">T</span>();}</span><br></pre></td></tr></table></figure>
<h3 id="泛型类的静态上下文中类型变量无效"><a class="markdownIt-Anchor" href="#泛型类的静态上下文中类型变量无效"></a> 泛型类的静态上下文中类型变量无效</h3>
<p>不能在静态域或方法中引用类型变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&lt;T&gt;</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T singleInstance;	<span class="comment">//错误使用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T getSingleInstance	<span class="comment">//错误使用</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(singleInstance == <span class="literal">null</span>) <span class="keyword">return</span> singleInstance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h1 id="集合"><a class="markdownIt-Anchor" href="#集合"></a> 集合</h1>
<p>java.util 包中的集合类就像一个装有多个对象的容器，提到容器 就不难想到数组，数组与集合的不同之处在于：</p>
<p><strong>数组的长度是固定的，集合的长度是可变的；数组既可以存放基本数据类型的数据，又可以存放对象，集合只能存放对象</strong>。集合类包括<strong>List</strong>集合，<strong>Set</strong>集合和<strong>Map</strong>集合，其中List与Set继承了Collection接口</p>
<p><img src="D:%5CStudy%5CJava%E7%9F%A5%E8%AF%86%5Cmarkdown%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%5C%E9%9B%86%E5%90%88%E7%B1%BB.png" alt=""></p>
<ul>
<li>Collection接口的常用方法</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>功能描述</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>add(Object e)</td>
<td>将指定的对象添加到当前集合内</td>
<td></td>
</tr>
<tr>
<td>remove(Object o)</td>
<td>将指定的对象从到当前集合内移除</td>
<td></td>
</tr>
<tr>
<td>isEmpty()</td>
<td>返回boolean值，用于判断当前集合是否为空</td>
<td></td>
</tr>
<tr>
<td>iterator()</td>
<td>返回用于遍历集合内元素的迭代器</td>
<td></td>
</tr>
<tr>
<td>size()</td>
<td>返回int型值，获取当前集合中元素的个数</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="list-集合"><a class="markdownIt-Anchor" href="#list-集合"></a> List 集合</h2>
<p>List集合中的元素允许重复，且各元素的顺序就是添加元素的顺序。</p>
<h3 id="list-接口"><a class="markdownIt-Anchor" href="#list-接口"></a> List 接口</h3>
<p>List接口继承了Collection接口，因此可以使用Collection接口中的所有方法。此外，List接口还定义了两个非常重要的方法</p>
<ul>
<li>get(int index)：获得指定索引位置上的元素</li>
<li>set(int  index,Object obj)：将集合中指定索引位置的对象修改为指定的对象</li>
</ul>
<h3 id="list接口的实现类"><a class="markdownIt-Anchor" href="#list接口的实现类"></a> List接口的实现类</h3>
<p>因为List接口不能被直接实例化，所以Java提供了List接口的实现类，其中最常用的实现类是 <strong>ArrayList</strong> 类与**LinkedList **类。</p>
<ul>
<li>[x] <strong>ArrayList</strong>以数组的形式保存集合中的元素，能够根据索引位置随机且快速地访问集合中元素</li>
<li>[x] **LinkedList **以链表结构保存集合中的元素，随机访问集合中的元素性能较差，但向集合中插入素和删除元素的性能出色</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;E&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();    <span class="comment">//E代表元素类型，如果集合中的元素为字符串类型，则E即为String</span></span><br><span class="line">List&lt;E&gt; list2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<ul>
<li>与数组相同，集合的索引也是从 0 开始</li>
</ul>
<h3 id="iterator-迭代器"><a class="markdownIt-Anchor" href="#iterator-迭代器"></a> Iterator 迭代器</h3>
<p>iterator迭代器的常用方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>hasNext()</td>
<td>如果仍有元素可以迭代，则返回true</td>
</tr>
<tr>
<td>next()</td>
<td>返回迭代的下一个元素，返回类型是Object</td>
</tr>
<tr>
<td>remove()</td>
<td>从迭代器指向的Colletion中移除迭代器返回的最后一个元素</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        Collection&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">"a"</span>);</span><br><span class="line">        list.add(<span class="string">"b"</span>);</span><br><span class="line">        list.add(<span class="string">"c"</span>);</span><br><span class="line">        Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext()){</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> it.next();</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="set-集合"><a class="markdownIt-Anchor" href="#set-集合"></a> Set 集合</h2>
<p><strong>Set</strong> 集合中的元素不按特定的方式排序，只是简单地存放在集合中，但 <strong>Set</strong> 集合中的<strong>元素不能重复</strong></p>
<h3 id="set-接口"><a class="markdownIt-Anchor" href="#set-接口"></a> Set 接口</h3>
<p>Set 接口继承了Collection接口，因此可以使用Collection接口中的所有方法。</p>
<p>由于Set集合中的元素不能重复，因此在向Set集合中添加元素时，需要先判断新增元素是否已经存在集合中，再确定是否执行添加操作。</p>
<h3 id="set-接口的实现类"><a class="markdownIt-Anchor" href="#set-接口的实现类"></a> Set 接口的实现类</h3>
<p>Set接口的实现类有<strong>HashSet</strong> 类和 <strong>TreeSet</strong> 类</p>
<ul>
<li>[x] <strong>HashSet</strong>是Set接口的一个实现类，它不允许有重复元素</li>
<li>[x] <strong>TreeSet</strong>不仅实现了Set接口，还实现了 <strong>java.util.ShortedSet</strong> 接口，因此在遍历使用TreeSet类实现的Set集合中的元素时，会默认将元素<strong>按升序排列</strong>。在创建TreeSet对象时，通过使用 <strong>Comparator</strong> 接口，还可以实现制定排序，例如降序排序</li>
</ul>
<ul>
<li><strong>Comparator</strong> 接口，即“比较器”，它提供一个抽象方法compara(T  o1, T  o2)，这个方法指定了两个对象的比较规则，如果o1大于o2，返回正数；如果o1等于o2，返回 0；否则返回负数（通常为-1）</li>
</ul>
<p>TreeSet类增加的方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>first()</td>
<td>返回Set中当前的第一个元素</td>
</tr>
<tr>
<td>last()</td>
<td>返回Set中当前的最后一个元素</td>
</tr>
<tr>
<td>comparator()</td>
<td>返回对此Set中的元素进行排序的比较器，如果此Set使用自然顺序，则返回null</td>
</tr>
<tr>
<td>headSet(E toElement)</td>
<td>返回一个新的Set集合，新集合是toElement(不包括)之前的所有对象</td>
</tr>
<tr>
<td>subSet(E fromElement, E toElement)</td>
<td>返回一个新的Set集合，新集合是fromElement(包括)对像与toElement(不包括)之间的所有对象</td>
</tr>
<tr>
<td>tailSet(E fromElement)</td>
<td>返回一个新的Set集合，新集合包含fromElement(包括)对像之后的所有对象</td>
</tr>
</tbody>
</table>
<h2 id="map-映射"><a class="markdownIt-Anchor" href="#map-映射"></a> Map 映射</h2>
<p>在程序中，如果想要存储具有<strong>映射关系</strong>的数据，就需要使用Map映射</p>
<h3 id="map-接口"><a class="markdownIt-Anchor" href="#map-接口"></a> Map 接口</h3>
<p>Map接口虽然没有继承Collection接口，但提供了key到value的映射关系。Map接口中<strong>不能包含相同的 key ，并且每个 key 只能映射一个 value</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>put(Object key,Object value)</td>
<td>向集合中添加指定的key与value的映射关系</td>
</tr>
<tr>
<td>containsKey(Object key)</td>
<td>如果此映射包含指定key的映射关系，则返回true</td>
</tr>
<tr>
<td>containsValue(Object value)</td>
<td>如果此映射将一个或多个key映射到指定值，则返回true</td>
</tr>
<tr>
<td>get(Object key)</td>
<td>如果存在指定的key对象，则返回该对象对应的值，否则返回null</td>
</tr>
<tr>
<td><strong>getOrDefault(Object key,V defaultValue)</strong></td>
<td><strong>获得与键值；如果未在映射中找到该键值，返回defaultValue</strong></td>
</tr>
<tr>
<td>keySet()</td>
<td>返回该集合中的所有key对象形成的 <strong>Set</strong> 集合</td>
</tr>
<tr>
<td>values()</td>
<td>返回该集合中所有值对象形成的 <strong>Collection</strong> 集合</td>
</tr>
</tbody>
</table>
<h3 id="map-接口的实现类"><a class="markdownIt-Anchor" href="#map-接口的实现类"></a> Map 接口的实现类</h3>
<p>Map接口常用的实现类有 <strong>HashMap</strong> 和 <strong>TreeMap</strong> 两种</p>
<ul>
<li>[x] <strong>HashMap</strong> 类虽然能够通过哈希表快速查找其内部的映射关系，但不保证映射的顺序。在key-value键值对中，由于key不能重复，所以最多只有一个key为null，但可以有无数多个value为null</li>
<li>[x] <strong>TreeMap</strong> 类不仅实现了Map接口，还实现了java.util.ShrotMap接口。由于使用TreeMap类实现的Map集合存储key-value键值对时，需要根据key进行排序，所以key不能为null</li>
</ul>
<h2 id="算法"><a class="markdownIt-Anchor" href="#算法"></a> 算法</h2>
<h3 id="集合与数组的转换"><a class="markdownIt-Anchor" href="#集合与数组的转换"></a> 集合与数组的转换</h3>
<p>将一个数组转换为集合，Arrays.asList包装器就可以实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer[] nums = <span class="keyword">new</span> <span class="title class_">Integer</span>[]{<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>};</span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(Arrays.asList(nums));</span><br><span class="line">list.add(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<p>将一个集合转换为数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line">Integer[] nums = list.toArray(<span class="keyword">new</span> <span class="title class_">Integer</span>[list.size()]);</span><br><span class="line">System.out.println(Arrays.toString(nums));</span><br></pre></td></tr></table></figure>
<h1 id="并发"><a class="markdownIt-Anchor" href="#并发"></a> 并发</h1>
<p>多线程与多进程的区别：进程是指一个内存中运行的应用程序，每个进程都有自己独立的地址空间(内存空间),用户每启动一个进程，操作系统就会为该进程分配一个独立的内存空间。一个进程可以启动多个线程。线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一 点在运行中必不可少的资源，但它可与同属一个进程的其它线程共享进程所拥有的全部资源。本质的区别在于每个进程拥有自己的一整套变量，而线程则共享数据。与进程相比较，线程更 “轻量级” ，创建，撤销一个线程比启动新进程的开销要小得多。</p>
<h2 id="线程"><a class="markdownIt-Anchor" href="#线程"></a> 线程</h2>
<p>Java的线程是通过 <code>java.lang.Thread</code> 类或者 <code>java.lang.Runnable</code> 接口编写代码来定义、实例化和启动的。Thread类实例只是一个对象，跟其他任何对象一样，具有成员变量和方法，且都储存在堆上。由于Java应用总是从main()方法开始运行，JVM启动时会有一个由主方法所定义的线程，称之为主线程。每个线程都是通过某个特定的Thread对象所对应的方法run()来完成其操作，方法run()称之为线程的线程体，<strong>Thread类必须以start()方法来启动一个线程</strong>，如直接通过run()方法来执行只是一个方法的调用，并不是一个线程的启动。在执行start()方法之前，Thread对象只是一个实例，并不是一个真正的线程。</p>
<h3 id="两种实现方式"><a class="markdownIt-Anchor" href="#两种实现方式"></a> 两种实现方式</h3>
<ol>
<li>继承 <code>Thread</code> 类并重写 <code>run</code> 方法。</li>
<li>实现 <code>runable</code> 接口并重写 <code>run</code> 方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以实现runable接口方式为例</span></span><br><span class="line"><span class="comment">// 用lambda表达式创建一个runable实例</span></span><br><span class="line"><span class="type">Runable</span> <span class="variable">r</span> <span class="operator">=</span> () -&gt;{   </span><br><span class="line">    task code</span><br><span class="line">};</span><br><span class="line"><span class="comment">// 由runable创建一个Thread对象</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>
<h2 id="线程状态"><a class="markdownIt-Anchor" href="#线程状态"></a> 线程状态</h2>
<p>线程可以有如下6种状态：</p>
<ul>
<li>New（新创建）</li>
<li>Runable（可运行）</li>
<li>Blocked（被阻塞）</li>
<li>Waiting（等待）</li>
<li>Timed waiting（计时等待）</li>
<li>Terminated（被终止）</li>
</ul>
<p>可调用 <code>getState</code> 方法确定当前线程的状态。</p>
<h3 id="新创建线程"><a class="markdownIt-Anchor" href="#新创建线程"></a> 新创建线程</h3>
<p>当用 <code>new</code> 操作符创建一个线程时，如 <code>new Thread(r)</code> ，该线程还没有开始运行，他的状态是new。</p>
<h3 id="可运行状态"><a class="markdownIt-Anchor" href="#可运行状态"></a> 可运行状态</h3>
<p>一旦调用 <code>start</code> 方法，线程处于 runable 状态。一个可运行的线程可能正在运行也可能没有运行，这取决于操作系统给线程提供的运行时间（一个正在运行的线程仍然处于可运行状态）</p>
<h3 id="被阻塞线程和等待线程"><a class="markdownIt-Anchor" href="#被阻塞线程和等待线程"></a> 被阻塞线程和等待线程</h3>
<p>还在更新中……</p>

    </div>

    
    
    
	<div>
	  
		<div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读!-------------</div>
    
</div>
	  
	</div>
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Double
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://teksab.cn/2022/07/15/Java%20EE/" title="Java核心技术">http://teksab.cn/2022/07/15/Java EE/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
           
          <div class="post-tags">
				<a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/03/27/Markdown%E6%A0%BC%E5%BC%8F/" rel="prev" title="Markdown书写格式">
      <i class="fa fa-chevron-left"></i> Markdown书写格式
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#java-%E6%A6%82%E8%BF%B0"><span class="nav-text"> Java 概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#jvm-jre%E5%92%8Cjdk%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-text"> JVM、JRE和JDK的关系</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="nav-text"> Java基础语法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text"> 数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="nav-text"> 整数类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E7%B1%BB%E5%9E%8B"><span class="nav-text"> 浮点类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B"><span class="nav-text"> 字符类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#boolean-%E7%B1%BB%E5%9E%8B"><span class="nav-text"> Boolean 类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E9%87%8F"><span class="nav-text"> 变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F-2"><span class="nav-text"> 变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F"><span class="nav-text"> 常量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text"> 运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text"> 位运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text"> 三元运算符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text"> 字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#string-%E7%B1%BB"><span class="nav-text"> String 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%BF%9E%E6%8E%A5"><span class="nav-text"> 字符串的连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text"> 不可变字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E4%B8%B2%E4%B8%8Enull%E4%B8%B2"><span class="nav-text"> 空串与NULL串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%90%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BF%A1%E6%81%AF"><span class="nav-text"> 提取字符串信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-text"> 字符串的操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text"> 构建字符串</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="nav-text"> 输入输出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%8F%96%E8%BE%93%E5%85%A5"><span class="nav-text"> 读取输入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA"><span class="nav-text"> 格式化输出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA"><span class="nav-text"> 文件输入与输出</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B"><span class="nav-text"> 控制流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5"><span class="nav-text"> 条件语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5"><span class="nav-text"> 循环语句</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%A7%E6%95%B0%E5%80%BC"><span class="nav-text"> 大数值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-text"> 数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-text"> 一维数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#for-each%E8%AF%AD%E5%8F%A5"><span class="nav-text"> for each语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%95%B0%E7%BB%84"><span class="nav-text"> 命令行数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E6%8B%B7%E8%B4%9D"><span class="nav-text"> 数组拷贝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-text"> 多维数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-text"> 数组的基本操作</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-text"> 面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1"><span class="nav-text"> 类与对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="nav-text"> 成员变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="nav-text"> 成员方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="nav-text"> 局部变量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%9F%9F%E4%B8%8E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="nav-text"> 静态域与静态方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="nav-text"> 静态变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="nav-text"> 静态方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-text"> 静态代码块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95"><span class="nav-text"> 工厂方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E4%B8%BB%E6%96%B9%E6%B3%95"><span class="nav-text"> 类的主方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0"><span class="nav-text"> 对象构造</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD"><span class="nav-text"> 重载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E5%8F%82%E6%95%B0%E6%9E%84%E9%80%A0%E5%99%A8"><span class="nav-text"> 无参数构造器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%9E%84%E9%80%A0%E5%99%A8"><span class="nav-text"> 调用另一个构造器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9D%97"><span class="nav-text"> 初始化块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E6%9E%90%E6%9E%84%E4%B8%8Efinalize%E6%96%B9%E6%B3%95"><span class="nav-text"> 对象析构与finalize方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%85"><span class="nav-text"> 包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%AF%BC%E5%85%A5"><span class="nav-text"> 类的导入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86%E7%B1%BB%E6%94%BE%E5%85%A5%E5%8C%85%E4%B8%AD"><span class="nav-text"> 将类放入包中</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%85%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-text"> 包作用域</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A"><span class="nav-text"> 文档注释</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E9%87%8A%E7%9A%84%E6%8F%92%E5%85%A5"><span class="nav-text"> 注释的插入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E6%B3%A8%E9%87%8A"><span class="nav-text"> 方法注释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E7%94%A8%E6%B3%A8%E9%87%8A"><span class="nav-text"> 通用注释</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-text"> 继承</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E8%B6%85%E7%B1%BB%E5%92%8C%E5%AD%90%E7%B1%BB"><span class="nav-text"> 类，超类和子类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%80%81"><span class="nav-text"> 多态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%BB%E6%AD%A2%E7%BB%A7%E6%89%BFfinal%E7%B1%BB%E5%92%8C%E6%96%B9%E6%B3%95"><span class="nav-text"> 阻止继承：final类和方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="nav-text"> 抽象类与抽象方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="nav-text"> 访问控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%A3%B0%E6%98%8E%E5%8F%8A%E5%AE%9E%E7%8E%B0"><span class="nav-text"> 接口的声明及实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="nav-text"> 多重继承</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%80%E6%9C%89%E7%B1%BB%E7%9A%84%E7%88%B6%E7%B1%BBobject"><span class="nav-text"> 所有类的父类——Object</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#equals-%E6%96%B9%E6%B3%95"><span class="nav-text"> equals() 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hashcode%E6%96%B9%E6%B3%95"><span class="nav-text"> HashCode方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tostring-%E6%96%B9%E6%B3%95"><span class="nav-text"> toString() 方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E6%95%B0%E7%BB%84%E5%88%97%E8%A1%A8"><span class="nav-text"> 泛型数组列表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84%E5%88%97%E8%A1%A8%E5%85%83%E7%B4%A0"><span class="nav-text"> 访问数组列表元素</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%8C%85%E8%A3%85%E5%99%A8%E4%B8%8E%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1"><span class="nav-text"> 对象包装器与自动装箱</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E6%95%B0%E9%87%8F%E5%8F%AF%E5%8F%98%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-text"> 参数数量可变的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%92%8C%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="nav-text"> 常用类和枚举类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#math-%E7%B1%BB"><span class="nav-text"> Math 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#random%E7%B1%BB"><span class="nav-text"> Random类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#date-%E7%B1%BB"><span class="nav-text"> Date 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="nav-text"> 枚举类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84"><span class="nav-text"> 反射</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-text"> 接口与内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-text"> 接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-text"> 接口的特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-text"> 接口与抽象类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%85%8B%E9%9A%86"><span class="nav-text"> 对象克隆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%9B%9E%E8%B0%83"><span class="nav-text"> 接口与回调</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text"> lambda表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95"><span class="nav-text"> 语法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-text"> 内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%86%85%E9%83%A8%E7%B1%BB%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1%E7%8A%B6%E6%80%81"><span class="nav-text"> 使用内部类访问对象状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E7%89%B9%E6%AE%8A%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99"><span class="nav-text"> 内部类的特殊语法规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-text"> 匿名内部类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-text"> 静态内部类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%90%86"><span class="nav-text"> 代理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8-%E6%96%AD%E8%A8%80-%E6%97%A5%E5%BF%97%E5%92%8C%E8%B0%83%E8%AF%95"><span class="nav-text"> 异常、断言、日志和调试</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF"><span class="nav-text"> 处理错误</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%88%86%E7%B1%BB"><span class="nav-text"> 异常分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E5%B7%B2%E6%A3%80%E6%9F%A5%E5%BC%82%E5%B8%B8"><span class="nav-text"> 声明已检查异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="nav-text"> 如何抛出异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%BC%82%E5%B8%B8%E7%B1%BB"><span class="nav-text"> 创建异常类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8"><span class="nav-text"> 捕获异常</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#finally-%E5%AD%90%E5%8F%A5"><span class="nav-text"> finally 子句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%A6%E8%B5%84%E6%BA%90%E7%9A%84-try-%E8%AF%AD%E5%8F%A5"><span class="nav-text"> 带资源的 try 语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%9E%90%E5%A0%86%E6%A0%88%E8%B7%9F%E8%B8%AA%E5%85%83%E7%B4%A0"><span class="nav-text"> 分析堆栈跟踪元素</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="nav-text"> 泛型程序设计</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="nav-text"> 定义泛型类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="nav-text"> 泛型方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F%E7%9A%84%E9%99%90%E5%AE%9A"><span class="nav-text"> 类型变量的限定</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E4%BB%A3%E7%A0%81%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="nav-text"> 泛型代码和虚拟机</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BF%BB%E8%AF%91%E6%B3%9B%E5%9E%8B%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text"> 翻译泛型表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BF%BB%E8%AF%91%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="nav-text"> 翻译泛型方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%A6%E6%9D%9F%E4%B8%8E%E5%B1%80%E9%99%90%E6%80%A7"><span class="nav-text"> 约束与局限性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E8%83%BD%E7%94%A8%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="nav-text"> 不能用基本类型实例化类型参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%9E%8B%E6%9F%A5%E8%AF%A2%E5%8F%AA%E9%80%82%E7%94%A8%E4%BA%8E%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B"><span class="nav-text"> 运行时类型查询只适用于原始类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E8%83%BD%E5%88%9B%E5%BB%BA%E5%8F%82%E6%95%B0%E5%8C%96%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%95%B0%E7%BB%84"><span class="nav-text"> 不能创建参数化类型的数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E8%83%BD%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F"><span class="nav-text"> 不能实例化类型变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%AD%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F%E6%97%A0%E6%95%88"><span class="nav-text"> 泛型类的静态上下文中类型变量无效</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9B%86%E5%90%88"><span class="nav-text"> 集合</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#list-%E9%9B%86%E5%90%88"><span class="nav-text"> List 集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#list-%E6%8E%A5%E5%8F%A3"><span class="nav-text"> List 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#list%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="nav-text"> List接口的实现类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#iterator-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-text"> Iterator 迭代器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#set-%E9%9B%86%E5%90%88"><span class="nav-text"> Set 集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#set-%E6%8E%A5%E5%8F%A3"><span class="nav-text"> Set 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#set-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="nav-text"> Set 接口的实现类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#map-%E6%98%A0%E5%B0%84"><span class="nav-text"> Map 映射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#map-%E6%8E%A5%E5%8F%A3"><span class="nav-text"> Map 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="nav-text"> Map 接口的实现类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%B3%95"><span class="nav-text"> 算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E4%B8%8E%E6%95%B0%E7%BB%84%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-text"> 集合与数组的转换</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91"><span class="nav-text"> 并发</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B"><span class="nav-text"> 线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-text"> 两种实现方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="nav-text"> 线程状态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B0%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="nav-text"> 新创建线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81"><span class="nav-text"> 可运行状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A2%AB%E9%98%BB%E5%A1%9E%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%AD%89%E5%BE%85%E7%BA%BF%E7%A8%8B"><span class="nav-text"> 被阻塞线程和等待线程</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Double"
      src="/images/author.jpg">
  <p class="site-author-name" itemprop="name">Double</p>
  <div class="site-description" itemprop="description">KEEP CALM & Carry On</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">2</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Tekasb" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Tekasb" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:csp1999005@163.com" title="E-Mail → mailto:csp1999005@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


<div style="">
  <canvas id="canvas" style="width:60%;">当前浏览器不支持canvas，请更换浏览器后再试</canvas>
</div>
<script>
(function(){

   var digit=
    [
        [
            [0,0,1,1,1,0,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,0,1,1,0],
            [0,0,1,1,1,0,0]
        ],//0
        [
            [0,0,0,1,1,0,0],
            [0,1,1,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [1,1,1,1,1,1,1]
        ],//1
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,1,1],
            [1,1,1,1,1,1,1]
        ],//2
        [
            [1,1,1,1,1,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//3
        [
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,0],
            [0,0,1,1,1,1,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,1,1,0],
            [1,1,1,1,1,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,1]
        ],//4
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,1,1,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//5
        [
            [0,0,0,0,1,1,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//6
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0]
        ],//7
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//8
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,1,1,0,0,0,0]
        ],//9
        [
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0]
        ]//:
    ];

var canvas = document.getElementById('canvas');

if(canvas.getContext){
    var cxt = canvas.getContext('2d');
    //声明canvas的宽高
    var H = 100,W = 700;
    canvas.height = H;
    canvas.width = W;
    cxt.fillStyle = '#f00';
    cxt.fillRect(10,10,50,50);

    //存储时间数据
    var data = [];
    //存储运动的小球
    var balls = [];
    //设置粒子半径
    var R = canvas.height/20-1;
    (function(){
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        //存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这7个数字组成
        data.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
    })();

    /*生成点阵数字*/
    function renderDigit(index,num){
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    cxt.beginPath();
                    cxt.arc(14*(R+2)*index + j*2*(R+1)+(R+1),i*2*(R+1)+(R+1),R,0,2*Math.PI);
                    cxt.closePath();
                    cxt.fill();
                }
            }
        }
    }

    /*更新时钟*/
    function updateDigitTime(){
        var changeNumArray = [];
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        var NewData = [];
        NewData.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
        for(var i = data.length-1; i >=0 ; i--){
            //时间发生变化
            if(NewData[i] !== data[i]){
                //将变化的数字值和在data数组中的索引存储在changeNumArray数组中
                changeNumArray.push(i+'_'+(Number(data[i])+1)%10);
            }
        }
        //增加小球
        for(var i = 0; i< changeNumArray.length; i++){
            addBalls.apply(this,changeNumArray[i].split('_'));
        }
        data = NewData.concat();
    }

    /*更新小球状态*/
    function updateBalls(){
        for(var i = 0; i < balls.length; i++){
            balls[i].stepY += balls[i].disY;
            balls[i].x += balls[i].stepX;
            balls[i].y += balls[i].stepY;
            if(balls[i].x > W + R || balls[i].y > H + R){
                balls.splice(i,1);
                i--;
            }
        }
    }

    /*增加要运动的小球*/
    function addBalls(index,num){
        var numArray = [1,2,3];
        var colorArray =  ["#3BE","#09C","#A6C","#93C","#9C0","#690","#FB3","#F80","#F44","#C00"];
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    var ball = {
                        x:14*(R+2)*index + j*2*(R+1)+(R+1),
                        y:i*2*(R+1)+(R+1),
                        stepX:Math.floor(Math.random() * 4 -2),
                        stepY:-2*numArray[Math.floor(Math.random()*numArray.length)],
                        color:colorArray[Math.floor(Math.random()*colorArray.length)],
                        disY:1
                    };
                    balls.push(ball);
                }
            }
        }
    }

    /*渲染*/
    function render(){
        //重置画布宽度，达到清空画布的效果
        canvas.height = 100;
        //渲染时钟
        for(var i = 0; i < data.length; i++){
            renderDigit(i,data[i]);
        }
        //渲染小球
        for(var i = 0; i < balls.length; i++){
            cxt.beginPath();
            cxt.arc(balls[i].x,balls[i].y,R,0,2*Math.PI);
            cxt.fillStyle = balls[i].color;
            cxt.closePath();
            cxt.fill();
        }
    }

    clearInterval(oTimer);
    var oTimer = setInterval(function(){
        //更新时钟
        updateDigitTime();
        //更新小球状态
        updateBalls();
        //渲染
        render();
    },50);
}

})();
</script>

<div class="site-overview-wrap sidebar-panel sidebar-panel-active">
<div class="site-overview">
    


</div>
</div>

      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Double</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">44k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">40 分钟</span>
</div>

        








      </div>
    </footer>
  </div>

  
  
  <script color='34,34,34' opacity='0.5' zIndex='-1' count='150' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex@0/dist/katex.min.css">


  

</body>
</html>
